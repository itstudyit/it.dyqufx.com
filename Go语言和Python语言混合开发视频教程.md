# Go语言和Python语言混合开发视频教程

## 联系方式

客服微信号：itziyuan_xiaozhi

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/common/20240614073449/666b82192834a.jpg" width="200" height="200" alt="二维码">

## 课程简介

下载链接：https://it.dyqufx.com/posts?id=3523

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/yun/20240515185215/664493df455e6.jpg" width="500" alt="">

  〖课程介绍〗:

 Go语言和Python语言混合开发视频教程(22.27G)

 Go语言和Python语言混合开发视频教程



 〖课程目录〗:

 第1章 【阶段一：Go语言基础】1~13章内容试看

 1-1 Go+python双语言混合开发-课程导学.mp4

 1-2 课程资源获取方式 &#8211; 非常重要！！！.mp4

 1-3 课程中需要用到的开发环境介绍.mp4

 1-4 windows中安装centos7虚拟机.mp4

 1-5 xshell的安装和使用.mp4

 1-6 git的安装和配置.mp4

 1-7 docker和docker-compose的安装.mp4

 1-8 mysql和navicat的安装和配置.mp4

 1-9 python的安装和配置.mp4

 1-10 python虚拟环境的安装和配置.mp4

 1-11 pycharm的安装和配置.mp4

 1-12 windows下安装go和goland的配置 &#8211; 很重要！！.mp4

 1-13 linux下go开发环境搭建.mp4

 1-14 windows下安装nodejs开发环境.mp4

 1-15 linxu下安装和配置nodejs开发环境.mp4

 1-16 代码提示神器 &#8211; kite的安装和配置.mp4

 1-17 go语言介绍.mp4

 1-18 go的hello world-1.mp4

 1-19 变量的定义.mp4

 1-20 匿名变量是什么？.mp4

 1-21 go语言中的常量是什么？.mp4

 1-22 常量的iota有什么用？.mp4

 1-23 变量的作用域也有很多细节你可能没有在意.mp4

 第2章 计算机组成原理快速扫盲

 2-1 为什么我们要学习计算机组成原理.mp4

 2-2 二进制、八进制和十六进制 .mp4

 2-3 ascii码表是什么？.mp4

 第3章 基本数据类型、运算符和表达式

 3-1 go语言提供了哪些整数类.mp4

 3-2 float类型和其它数据类型.mp4

 3-3 go语言最基本的数据类型转换.mp4

 3-4 strconv的parse类函数将字符串转换为其他类型.mp4

 3-5 python的基本数据类型转换.mp4

 3-6 go语言运算符.mp4

 第4章 python的海象运算符和变量注解

 4-1 python3.8的新特性-海象运算符.mp4

 4-2 python的变量居然也能申明类型！.mp4

 4-3 python如何强制检查函数的参数类型.mp4

 第5章 字符串的基本操作

 5-1 为什么len函数获取中文字符串长度有问题？.mp4

 5-2 什么是转义符？.mp4

 5-3 子串查询、子串统计、开始和结尾判断.mp4

 5-4 子串的替换、连接和分割.mp4

 5-5 格式化的输入和输出.mp4

 第6章 条件语句和循环语句

 6-1 if条件控制语句.mp4

 6-2 go语言的for循环.mp4

 6-3 go语言的for range用法.mp4

 6-4 goto语句能帮我们完成什么功能？.mp4

 6-5 switch语句能让代码可读性更高.mp4

 6-6 python中如何实现switch的效果？.mp4

 第7章 最常用的复杂数据类型 &#8211; map、数组、 切片

 7-1 数组的多种初始化方式.mp4

 7-2 使用for range对数组元素求和.mp4

 7-3 go语言中的数组是值类型 &#8211; 很重要！.mp4

 7-4 go语言的slice是什么？.mp4

 7-5 slice切片的的基本操作.mp4

 7-6 go和python的切片的区别.mp4

 7-7 slice使用的时候你有没有遇到过这些奇怪的现象？.mp4

 7-8 slice的底层存储原理-1.mp4

 7-9 slice的底层存储原理-2.mp4

 7-10 当append函数遇到make会产生的坑.mp4

 7-11 map的定义和基本操作.mp4

 第8章 go语言的利器- 指针

 8-1 什么是指针.mp4

 8-2 go的指针和c语言的指针有什么区别？.mp4

 8-3 make函数和new函数.mp4

 8-4 图解new函数的执行过程.mp4

 8-5 go语言中的nil和python中的None有什么区别？.mp4

 第9章 go语言的函数

 9-1 函数的各种定义.mp4

 9-2 通过省略号设置参数个数不定长.mp4

 9-3 go语言中的函数是一等公民.mp4

 9-4 python中的finally的执行顺序你真的弄懂了吗？.mp4

 9-5 defer的作用和多个defer的执行顺序.mp4

 9-6 defer机制你忽略了很多细节.mp4

 9-7 python是如何处理代码错误和异常的？.mp4

 9-8 panic和recover的坑.mp4

 第10章 go语言的结构体

 10-1 type的5种应用场景.mp4

 10-2 python中的class封装性和namedtuple.mp4

 10-3 结构体的定义以及大小写对结构的影响.mp4

 10-4 结构体的实例化和new函数.mp4

 10-5 结构体如何绑定方法？.mp4

 10-6 通过内嵌结构体实现继承的效果.mp4

 10-7 结构体标签的作用是什么？.mp4

 第11章 go语言的接口

 11-1 python中的鸭子类型就是go的接口设计理念.mp4

 11-2 go语言中的接口是一种类型.mp4

 11-3 为什么说接口是一种抽象类型？.mp4

 11-4 接口也支持继承.mp4

 11-5 go的error是一个接口.mp4

 11-6 空接口的应用场景.mp4

 11-7 接口的类型断言.mp4

 11-8 通过接口协议去理解sort的本质.mp4

 第12章 包管理和编码规范

 12-1 如何使用go modules.mp4

 12-2 go的包和python的包区别.mp4

 12-3 go的import的各种姿势.mp4

 12-4 package和init函数的关系.mp4

 12-5 gopath开发模式和go modules开发模式对比.mp4

 12-6 go编码规范-1.mp4

 12-7 go编码规范 &#8211; 2.mp4

 12-8 python编码规范.mp4

 第13章 go并发编程

 13-1 go的goroutine.mp4

 13-2 go的协程和python协程对比.mp4

 13-3 使用waitgroup控制协程退出.mp4

 13-4 使用互斥锁同步协程.mp4

 13-5 使用RWMutex锁同步协程.mp4

 13-6 通过channel进行goroutine间的通信.mp4

 13-7 通过for range遍历channel和close关闭channel.mp4

 13-8 双向和单向的channel.mp4

 13-9 使用channel容易出现deadlock的原因.mp4

 13-10 go中select的应用场景.mp4

 13-11 context的应用场景.mp4

 13-12 通过context控制超时.mp4

 第14章 【阶段二：多语言通信基础 &#8211; gRPC】14~17章内容2

 14-1 什么是rpc？rpc开发的挑战是什么？-1.mp4

 14-2 什么是rpc？rpc开发的挑战是什么？- 2.mp4

 14-3 使用httpserver实现rpc.mp4

 14-4 rpc的开发要素分析.mp4

 14-5 基于xml的rpc库.mp4

 14-6 基于json的rpc技术.mp4

 14-7 基于zeromq的rpc框架.mp4

 第15章 go的rpc体验

 15-1 go快速体验rpc开发.mp4

 15-2 替换rpc的序列化协议为json.mp4

 15-3 替换rpc的传输协议为http.mp4

 15-4 进一步改造rpc调用的代码-1.mp4

 15-5 进一步改造rpc调用的代码-2.mp4

 第16章 grpc快速入门

 16-1 什么是grpc和protobuf.mp4

 16-2 python下体验protobuf.mp4

 16-3 python体验grpc开发.mp4

 16-4 python下生产的grpc文件import路径有问题的探讨.mp4

 16-5 go下grpc快速体验 &#8211; 1.mp4

 16-6 go下grpc快速体验-2.mp4

 16-7 go和python互相调用.mp4

 16-8 grpc的流模式的定义.mp4

 16-9 grpc的单向流，双向流代码实现.mp4

 第17章 protobuf和grpc进阶

 17-1 protobuf的基本类型和默认值，python操作的坑.mp4

 17-2 option go_package的作用.mp4

 17-3 当proto文件不同步的时候容易出现的问题.mp4

 17-4 proto文件中引入其他的proto文件.mp4

 17-5 嵌套的message对象.mp4

 17-6 protobuf中的enum枚举类型.mp4

 17-7 map类型.mp4

 17-8 使用protobuf内置的timestamp类型.mp4

 17-9 grpc配合asyncio使用.mp4

 17-10 grpc的metadata机制-go.mp4

 17-11 python操作metada.mp4

 17-12 grpc拦截器 &#8211; go.mp4

 17-13 python实现grpc的拦截器.mp4

 17-14 通过拦截器和metadata实现grpc的auth认证.mp4

 17-15 grpc的验证器.mp4

 17-16 grpc中的错误处理.mp4

 17-17 grpc的超时机制.mp4

 第18章 【阶段三：需求分析、架构设计、orm和web框架基础】18~22章内容

 18-1 如何启动电商系统和后台管理系统.mp4

 18-2 后台管理系统需求.mp4

 18-3 电商系统需求分析.mp4

 第19章 架构设计

 19-1 单体应用如何部署？.mp4

 19-2 单体应用开发痛点.mp4

 19-3 单体应用的架构演变.mp4

 19-4 服务拆分变动.mp4

 19-5 微服务的基本拆分.mp4

 19-6 分层微服务架构.mp4

 19-7 微服务需要解决的问题 &#8211; 重要！！.mp4

 第20章 yapi的安装和配置

 20-1 前后端分离的系统开发演变过程.mp4

 20-2 接口文档管理之痛.mp4

 20-3 yapi的安装和配置.mp4

 20-4 yapi基本功能使用.mp4

 20-5 接口的导入和导出.mp4

 第21章 python的orm-peewee

 21-1 peewee的安装和入门-1.mp4

 21-2 peewee的安装和入门 &#8211; 2.mp4

 21-3 数据的更新和删除.mp4

 21-4 多条插入、 or查询.mp4

 21-5 模糊查询、字典展示、排序、limit和去重.mp4

 21-6 聚合函数、执行原生的sql语句.mp4

 21-7 多表查询和反向查询.mp4

 21-8 避免n加1查询问题.mp4

 第22章 go的web框架-gin

 22-1 gin的helloworld体验.mp4

 22-2 使用New和Default初始化路由器的区别.mp4

 22-3 gin的路由分组.mp4

 22-4 获取url中的变量.mp4

 22-5 获取get和post表单信息.mp4

 22-6 gin返回protobuf.mp4

 22-7 登录的表单验证.mp4

 22-8 注册表单的验证.mp4

 22-9 表单验证错误翻译成中文.mp4

 22-10 表单中文翻译的json格式化细节.mp4

 22-11 自定义gin中间件.mp4

 22-12 通过abort终止中间件后续逻辑的执行.mp4

 22-13 gin的中间件原理源码分析.mp4

 22-14 gin返回HTML.mp4

 22-15 加载多个html文件.mp4

 22-16 static静态文件的处理.mp4

 22-17 gin的优雅退出.mp4

 第23章 【第四阶段：第一个微服务 &#8211; 用户服务】23~25章内容

 23-1 新建虚拟环境和项目.mp4

 23-2 user表结构设计和生成.mp4

 23-3 md5信息摘要.mp4

 23-4 md5盐值加密解决用户密码安全问题.mp4

 23-5 proto接口定义和生成.mp4

 23-6 用户列表接口.mp4

 23-7 启动grpc服务.mp4

 23-8 日志库选型 &#8211; loguru.mp4

 23-9 优雅退出server.mp4

 23-10 通过argparse解析传递进入的参数.mp4

 23-11 通过id和mobile查询用户是否存在.mp4

 23-12 新建用户接口.mp4

 23-13 更新用户.mp4

 第24章 web层开发-gin基础项目架构

 24-1 新建项目和目录结构构建.mp4

 24-2 go高性能日志库 &#8211; zap使用.mp4

 24-3 zap的文件输出.mp4

 24-4 集成zap和理由初始到gin的启动过程 &#8211; 1.mp4

 24-5 集成zap和理由初始到gin的启动过程-2.mp4

 24-6 gin调用grpc服务-1.mp4

 24-7 gin调用grpc服务-2.mp4

 24-8 配置文件 &#8211; viper.mp4

 24-9 viper的配置环境开发环境和生产环境隔离.mp4

 24-10 viper集成到gin的web服务中.mp4

 第25章 web层开发-用户接口开发

 25-1 表单验证的初始化.mp4

 25-2 自定义mobile验证器.mp4

 25-3 登录逻辑完善.mp4

 25-4 session机制在微服务下的问题.mp4

 25-5 json web token的认证机制.mp4

 25-6 集成jwt到gin中.mp4

 25-7 给url添加登录权限验证.mp4

 25-8 如何解决前后端的跨域问题.mp4

 25-9 获取图片验证码.mp4

 25-10 阿里云发送短信.mp4

 25-11 redis保存验证码.mp4

 25-12 用户注册接口.mp4

 第26章 【阶段五：服务注册、服务发现、负载均衡、配置中心】26~29章内容

 26-1 什么是服务注册和发现以及技术选型.mp4

 26-2 consul的安装和配置.mp4

 26-3 服务注册和注销.mp4

 26-4 服务注册的健康检查.mp4

 26-5 配置grpc的健康检查.mp4

 26-6 第三方库实现服务注册.mp4

 26-7 go集成consul.mp4

 第27章 服务集成注册中心

 27-1 srv服务集成consul.mp4

 27-2 gin集成consul.mp4

 27-3 将用户的grpc连接配置到全局共用.mp4

 第28章 负载均衡

 28-1 动态获取可用端口.mp4

 28-2 什么是负载均衡，负载均衡的策略有哪些？.mp4

 28-3 常用负载均衡算法.mp4

 28-4 grpc从consul中同步服务信息并进行负载均衡-1.mp4

 28-5 grpc从consul中同步服务信息并进行负载均衡-2.mp4

 28-6 gin集成grpc的负载均衡.mp4

 第29章 配置中心

 29-1 为什么需要配置中心.mp4

 29-2 配置中心选型-apollo vs nacos.mp4

 29-3 nacos的安装.mp4

 29-4 nacos的组、配置集、命名空间.mp4

 29-5 python操作nacos配置.mp4

 29-6 service层集成nacos.mp4

 29-7 go操作nacos.mp4

 29-8 gin集成nacos.mp4

 第30章 【阶段六：电商系统中商品、图片、库存、订单和购物车服务、分布式锁】30~38章

 30-1 需求分析_.mp4

 30-2 商品分类的表机构设计.mp4

 30-3 物理删除还是逻辑删除.mp4

 30-4 其余表结构定义和数据导入.mp4

 30-5 定义proto文件.mp4

 30-6 商品服务器的启动.mp4

 30-7 商品列表页服务接口-1.mp4

 30-8 商品列表页服务接口-2.mp4

 30-9 测试商品列表页.mp4

 30-10 批量获取商品信息.mp4

 30-11 获取商品的详情和删除商品.mp4

 30-12 新建商品接口.mp4

 30-13 更新商品接口.mp4

 30-14 商品分类列表页-1.mp4

 30-15 商品分类列表页-2.mp4

 30-16 商品分类的其他接口.mp4

 30-17 轮播图相关功能.mp4

 30-18 品牌相关接口.mp4

 30-19 品牌分类相关接口.mp4

 第31章 商品服务-web等

 31-1 快速将用户的web服务转换成商品的web服务.mp4

 31-2 商品的列表页接口-1.mp4

 31-3 商品的列表页接口-2.mp4

 31-4 如何设计一个符合go风格的注册中心接口.mp4

 31-5 gin的退出后的服务注销.mp4

 31-6 用户的web服务服务注册和优雅退出.mp4

 31-7 新建商品.mp4

 31-8 获取商品详情.mp4

 31-9 商品删除，更新.mp4

 31-10 商品分类的接口.mp4

 31-11 轮播图接口和yapi的快速测试.mp4

 31-12 品牌和品牌分类接口 （proto同步脚本）.mp4

 31-13 品牌分类接口.mp4

 第32章 阿里云的oss服务

 32-1 为什么要使用阿里云oss.mp4

 32-2 oss的基本概念介绍.mp4

 32-3 使用代码控制文件上传.mp4

 32-4 前端直传oss的流程.mp4

 32-5 gin集成前端直传文件.mp4

 32-6 为什么我们需要内网穿透.mp4

 32-7 内网穿透技术解决前端直传的回调.mp4

 32-8 将oss集成到gin微服务中.mp4

 第33章 库存服务

 33-1 库存服务的重要性.mp4

 33-2 库存服务表结构设计.mp4

 33-3 proto接口设计.mp4

 33-4 配置启动库存服务.mp4

 33-5 设置库存和获取库存详情.mp4

 33-6 库存的扣减和事务.mp4

 33-7 库存归还.mp4

 33-8 测试库存服务接口.mp4

 33-9 为所有的商品添加库存信息.mp4

 第34章 分布式锁

 34-1 订单超卖问题是如何产生的？.mp4

 34-2 什么是分布式锁.mp4

 34-3 基于mysql的乐观锁机制实现.mp4

 34-4 redis分布式锁实现的基本原理.mp4

 34-5 基于setnx确保分布式锁的原子性.mp4

 34-6 如何解决分布式锁中的重点难题.mp4

 34-7 py-redis-lock核心源码分析.mp4

 34-8 集成redis分布式锁到库存服务.mp4

 34-9 基于redis的分布式锁的优缺点和其他的分布式锁实现方案.mp4

 第35章 订单和购物车服务-service层

 35-1 需求分析.mp4

 35-2 表结构设计.mp4

 35-3 proto文件定义.mp4

 35-4 启动订单服务.mp4

 35-5 购物车列表、添加商品到购物车接口.mp4

 35-6 更新购物车、删除购物车接口.mp4

 35-7 订单的列表页接口.mp4

 35-8 订单详情页接口.mp4

 35-9 新建订单 &#8211; 访问商品服务.mp4

 35-10 新建订单 &#8211; 访问库存扣减.mp4

 35-11 新建订单-本地事务确保创建成功.mp4

 35-12 测试接口.mp4

 第36章 订单和购物车服务-web等

 36-1 快速启动订单服务.mp4

 36-2 购物车列表页接口.mp4

 36-3 添加商品到购物车.mp4

 36-4 更新和删除购物车记录.mp4

 36-5 订单列表页.mp4

 36-6 订单详情接口开发和测试.mp4

 36-7 新建订单接口开发和测试.mp4

 第37章 用户操作服务-service层

 37-1 支付宝沙箱环境开发流程.mp4

 37-2 私钥、公钥的概念以及支付宝如何解决订单的安全性问题.mp4

 37-3 支付宝的公钥、私钥和回调url配置.mp4

 37-4 生成支付宝的支付url.mp4

 37-5 gin集成支付宝支付_3.mp4

 37-6 支付宝回调通知url逻辑接口.mp4

 第38章 用户操作服务-web等

 38-1 需求分析和表结构定义.mp4

 38-2 proto接口定义.mp4

 38-3 运行用户操作服务.mp4

 38-4 handler的代码解读.mp4

 38-5 web服务启动.mp4

 38-6 解读handler的代码.mp4

 38-7 调试收藏、收货地址、留言接口.mp4

 第39章 前后端联调

 39-1 启动online-store服务.mp4

 39-2 首页接口的请求分析.mp4

 39-3 商品列表页分析.mp4

 39-4 个人中心、订单相关功能联调.mp4

 39-5 前端文件直传的源码解析.mp4

 39-6 用户详情和更新接口.mp4

 39-7 后台管理系统-商品列表页.mp4

 第40章 【阶段七：分布式系统技术难点 &#8211; 分布式事务、幂等性机制】39~44章内容

 40-1 为什么订单会有超时机制.mp4

 40-2 数据库事务的ACID特性.mp4

 40-3 分布式系统中出现哪些故障会导致数据不一致？.mp4

 第41章 分布式理论基础和常见的分布式事务解决方案

 41-1 cap理论.mp4

 41-2 BASE理论.mp4

 41-3 2pc两阶段提交分布式事务.mp4

 41-4 TCC分布式事务实现方案.mp4

 41-5 TCC分布式事务实现方案-2.mp4

 41-6 基于本地消息的最终一致性方案.mp4

 41-7 基于可靠消息的最终一致性.mp4

 41-8 最大努力通知方案.mp4

 第42章 消息队列在微服务中的作用和选型

 42-1 mq的应用场景mp4.mp4

 42-2 mq消息队列技术选型mp4.mp4

 第43章 RocketMQ消息队列入门

 43-1 rocketmq的安装和配置mp4

 43-2 rocketmq的基本概念mp4.mp4

 43-3 rocketmq的消息类型mp4.mp4

 43-4 在linux中搭建python的rocketmq开发环境mp4.mp4

 43-5 pycharm在windows下获取linux下的开发体验mp4

 43-6 python发送rocketmq普通消息mp4

 43-7 python消费普通消息mp4.mp4

 43-8 python发送延迟消息mp4.mp4

 43-9 python发送事务消息.mp4

 第44章 实现基于可靠消息最终一致性的事务解决库存归还

 44-1 开始之前的网络问题 &#8211; 重要.mp4

 44-2 订单新建的过程中如果保证库存数据的最终一致性.mp4

 44-3 库存扣减在分布式事务中的特殊性.mp4

 44-4 订单新建前的事务消息准备.mp4

 44-5 基于回调实现消息的通信.mp4

 44-6 什么时候应该对事务消息进行确认？.mp4

 44-7 库存扣减事务的完善.mp4

 44-8 库存服务监听rocketmq消息.mp4

 44-9 库存扣减记录下扣减历史.mp4

 44-10 库存归还的细节处理.mp4

 44-11 启动所有微服务的注意事项.mp4

 44-12 测试分布式事务一致性.mp4

 44-13 订单超时归还的流程分析.mp4

 44-14 订单新建成功后发送延时消息.mp4

 44-15 订单超时后的库存归还实现.mp4

 44-16 测试库存的超时归还.mp4

 第45章 幂等性机制

 45-1 什么是服务雪崩.mp4

 45-2 超时、重试和幂等性机制.mp4

 45-3 哪些情况下需要考虑幂等性问题.mp4

 45-4 go的grpc重试机制.mp4

 45-5 python下实现重试机制.mp4

 45-6 常用的幂等性解决方案.mp4

 ^

 第46章 【阶段八：微服务的高可用保障 &#8211; 链路追踪、熔断、限流、降级】45~48章内容

 46-1 为什么我们需要链路追踪.mp4

 46-2 链路追踪技术选型.mp4

 46-3 jaeger的安装和架构介绍.mp4

 第47章 第二章 链路追踪open tracing和jaegerF

 47-1 python发送单个span.mp4

 47-2 发送多级调用的span消息.mp4

 47-3 grpc下发送span消息.mp4

 47-4 grpc下client_interceptor的源码解读.mp4

 47-5 grpc下server端发送span消息.mp4

 47-6 grpc下server_interceptor的源码解读.mp4

 47-7 在grpc的server端添加子链路.mp4

 第48章 gin和python集成jaeger

 48-1 go发送简单的span消息.mp4

 48-2 go下通过grpc发送span消息.mp4

 48-3 gin中添加拦截器实现jaeger注入.mp4

 48-4 修改grpc_opentracing源码.mp4

 48-5 配置订单服务的web层逻辑.mp4

 48-6 订单服务的service链路追踪实现.mp4

 第49章 熔断、限流 &#8211; sentinel

 49-1 什么是限流、熔断和降级.mp4

 49-2 sentinel和hystrix对比.mp4

 49-3 sentinel的qps限流.mp4

 49-4 sentinel的预热和冷启动.mp4

 49-5 sentinel的Throttling配置策略.mp4

 49-6 sentinel的熔断接口.mp4

 49-7 sentinel的熔断接口-基于错误数.mp4

 49-8 sentinel的熔断接口-基于错误率和慢请求.mp4

 49-9 gin集成sentinel实现限流.mp4

 49-10 python下集成CircuitBreaker.mp4

 49-11 python下使用ratelitmit进行限流.mp4

 第50章 【阶段九：API网关】49~50章内容

 50-1 什么是api网关.mp4

 50-2 api网关具备的功能有哪些？.mp4

 50-3 api网关技术选型.mp4

 50-4 kong的安装.mp4

 第51章 kong的基本功能

 51-1 kong的8001、800和1337端口号的关系.mp4

 51-2 基本的路由转发配置.mp4

 51-3 kong的service、routes、upstream的请求过程.mp4

 51-4 kong集成consul实现服务发现和负载均衡.mp4

 51-5 kong配置jwt实现登录校验.mp4

 51-6 kong配置反爬和ip黑名单.mp4

 第52章 【阶段十：jekins自动化部署】51~51章内容

 52-1 敏捷开发中的持续集成痛点.mp4

 52-2 安装jenkins和关闭防火墙.mp4

 52-3 jenkins构建服务器流程.mp4

 52-4 安装jenkins常用插件.mp4

 52-5 通过free style构建项目.mp4

 52-6 将构建服务器上的代码上传到运行服务器.mp4

 52-7 通过pipeline实现持续集成.mp4

 52-8 通过jenkinsfile管理构建pipeline脚本.mp4

 52-9 通过远程和其他工程触发构建.mp4

 52-10 定时构建和轮询SCM构建.mp4

 52-11 参数化pipeline构建项目.mp4

 第53章 jekins自动化部署

 53-1 有哪些服务器我们需要部署？.mp4

 53-2 前端代码上传到git并启动.mp4

 53-3 nginx中部署vuejs.mp4

 53-4 jenkens部署vuejs项目.mp4

 53-5 发布go项目到远程服务器上.mp4

 53-6 通过shell脚本启动gin服务.mp4

 53-7 构建和部署python微服务-1.mp4

 53-8 构建和部署python微服务-2.mp4

 课程资料

  