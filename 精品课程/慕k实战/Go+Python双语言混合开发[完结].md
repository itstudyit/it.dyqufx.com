# Go+Python双语言混合开发[完结]

## 联系方式

客服微信号：itziyuan_xiaozhi

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/common/20240614073449/666b82192834a.jpg" width="200" height="200" alt="二维码">

## 课程简介

下载链接：https://it.bcwex.shop/posts?id=982

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/yun/20240515153447/6644659741393.jpg" width="500" alt="">

  ┣━mksz469-Go+Python双语言混合开发[完结]

 ┣━第36章 订单和购物车服务-web等

 ┣━36-4 更新和删除购物车记录_ev[4][2].mp4

 ┣━36-6 订单详情接口开发和测试_ev[4][2].mp4

 ┣━36-1 快速启动订单服务_ev[4][2].mp4

 ┣━36-2 购物车列表页接口_ev[4][2].mp4

 ┣━36-7 新建订单接口开发和测试_ev[4][2].mp4

 ┣━36-3 添加商品到购物车_ev[4][2].mp4

 ┣━36-5 订单列表页_ev[4][2].mp4

 ┣━第7章 最常用的复杂数据类型 &#8211; map、数组、 切片

 ┣━7-11 map的定义和基本操作 _[3].mp4

 ┣━7-5 slice切片的的基本操作 _[3].mp4

 ┣━7-7 slice使用的时候你有没有遇到过这些奇怪的现象？ _[3].mp4

 ┣━7-8 slice的底层存储原理-1 _[3].mp4

 ┣━7-2 使用for range对数组元素求和 _[3].mp4

 ┣━7-4 go语言的slice是什么？ _[3].mp4

 ┣━7-9 slice的底层存储原理-2 _[3].mp4

 ┣━7-3 go语言中的数组是值类型 &#8211; 很重要！ _[3].mp4

 ┣━7-1 数组的多种初始化方式 _[3].mp4

 ┣━7-10 当append函数遇到make会产生的坑 _[3].mp4

 ┣━7-6 go和python的切片的区别 _[3].mp4

 ┣━第11章 go语言的接口

 ┣━11-3 为什么说接口是一种抽象类型？ _[3].mp4

 ┣━11-2 go语言中的接口是一种类型 _[3].mp4

 ┣━11-5 go的error是一个接口 _[3].mp4

 ┣━11-6 空接口的应用场景 _[3].mp4

 ┣━11-8 通过接口协议去理解sort的本质 _[3].mp4

 ┣━11-4 接口也支持继承 _[3].mp4

 ┣━11-1 python中的鸭子类型就是go的接口设计理念 _[3].mp4

 ┣━11-7 接口的类型断言 _[3].mp4

 ┣━第52章 【阶段十：jekins自动化部署】51~51章内容

 ┣━52-10 定时构建和轮询SCM构建_ev[4][2].mp4

 ┣━52-2 安装jenkins和关闭防火墙_ev[4][2].mp4

 ┣━52-3 jenkins构建服务器流程_ev[4][2].mp4

 ┣━52-11 参数化pipeline构建项目_ev[4][2].mp4

 ┣━52-8 通过jenkinsfile管理构建pipeline脚本_ev[4][2].mp4

 ┣━52-4 安装jenkins常用插件_ev[4][2].mp4

 ┣━52-7 通过pipeline实现持续集成_ev[4][2].mp4

 ┣━52-6 将构建服务器上的代码上传到运行服务器_ev[4][2].mp4

 ┣━52-9 通过远程和其他工程触发构建_ev[4][2].mp4

 ┣━52-1 敏捷开发中的持续集成痛点_ev[4][2].mp4

 ┣━52-5 通过free style构建项目_ev[4][2].mp4

 ┣━第46章 【阶段八：微服务的高可用保障 &#8211; 链路追踪、熔断、限流、降级】45~48章内容

 ┣━46-1 为什么我们需要链路追踪_ev[4][2].mp4

 ┣━46-3 jaeger的安装和架构介绍_ev[4][2].mp4

 ┣━46-2 链路追踪技术选型_ev[4][2].mp4

 ┣━第19章 架构设计

 ┣━19-3 单体应用的架构演变 _[3].mp4

 ┣━19-7 微服务需要解决的问题 &#8211; 重要！！ _[3].mp4

 ┣━19-6 分层微服务架构 _[3].mp4

 ┣━19-4 服务拆分变动 _[3].mp4

 ┣━19-1 单体应用如何部署？ _[3].mp4

 ┣━19-5 微服务的基本拆分 _[3].mp4

 ┣━19-2 单体应用开发痛点 _[3].mp4

 ┣━第35章 订单和购物车服务-service层

 ┣━35-9 新建订单 &#8211; 访问商品服务_ev[4][2].mp4

 ┣━35-3 proto文件定义_ev[4][2].mp4

 ┣━35-11 新建订单-本地事务确保创建成功_ev[4][2].mp4

 ┣━35-5 购物车列表、添加商品到购物车接口_ev[4][2].mp4

 ┣━35-6 更新购物车、删除购物车接口_ev[4][2].mp4

 ┣━35-2 表结构设计_ev[4][2].mp4

 ┣━35-8 订单详情页接口_ev[4][2].mp4

 ┣━35-4 启动订单服务_ev[4][2].mp4

 ┣━35-1 需求分析_ev[4][2].mp4

 ┣━35-7 订单的列表页接口_ev[4][2].mp4

 ┣━35-12 测试接口_ev[4][2].mp4

 ┣━35-10 新建订单 &#8211; 访问库存扣减_ev[4][2].mp4

 ┣━第45章 幂等性机制

 ┣━45-2 超时、重试和幂等性机制_ev[4][2].mp4

 ┣━45-4 go的grpc重试机制_ev[4][2].mp4

 ┣━45-3 哪些情况下需要考虑幂等性问题_ev[4][2].mp4

 ┣━45-5 python下实现重试机制_ev[4][2].mp4

 ┣━45-1 什么是服务雪崩_ev[4][2].mp4

 ┣━45-6 常用的幂等性解决方案_ev[4][2].mp4

 ┣━第10章 go语言的结构体

 ┣━10-6 通过内嵌结构体实现继承的效果 _[3].mp4

 ┣━10-3 结构体的定义以及大小写对结构的影响 _[3].mp4

 ┣━10-7 结构体标签的作用是什么？ _[3].mp4

 ┣━10-5 结构体如何绑定方法？ _[3].mp4

 ┣━10-1 type的5种应用场景 _[3].mp4

 ┣━10-2 python中的class封装性和namedtuple _[3].mp4

 ┣━10-4 结构体的实例化和new函数 _[3].mp4

 ┣━第43章 rocketmq消息队列入门

 ┣━43-8 python发送延迟消息mp4_ev[4][2].mp4

 ┣━43-4 在linux中搭建python的rocketmq开发环境mp4_ev[4][2].mp4

 ┣━43-7 python消费普通消息mp4_ev[4][2].mp4

 ┣━43-5 pycharm在windows下获取linux下的开发体验mp4_ev[4][2].mp4

 ┣━43-3 rocketmq的消息类型mp4_ev[4][2].mp4

 ┣━43-9 python发送事务消息_ev[4][2].mp4

 ┣━43-6 python发送rocketmq普通消息mp4_ev[4][2].mp4

 ┣━43-2 rocketmq的基本概念mp4_ev[4][2].mp4

 ┣━43-1 rocketmq的安装和配置mp4_ev[4][2].mp4

 ┣━第40章 【阶段七：分布式系统技术难点 &#8211; 分布式事务、幂等性机制】39~44章内容

 ┣━40-2 数据库事务的ACID特性_ev[4][2].mp4

 ┣━40-1 为什么订单会有超时机制_ev[4][2].mp4

 ┣━40-3 分布式系统中出现哪些故障会导致数据不一致？_ev[4][2].mp4

 ┣━第30章 【阶段六：电商系统中商品、图片、库存、订单和购物车服务、分布式锁】30~38章

 ┣━30-12 新建商品接口_ev[4][2].mp4

 ┣━30-10 批量获取商品信息_ev[4][2].mp4

 ┣━30-13 更新商品接口_ev[4][2].mp4

 ┣━30-17 轮播图相关功能_ev[4][2].mp4

 ┣━30-14 商品分类列表页-1_ev[4][2].mp4

 ┣━30-15 商品分类列表页-2_ev[4][2].mp4

 ┣━30-2 商品分类的表机构设计_ev[4][2].mp4

 ┣━30-16 商品分类的其他接口_ev[4][2].mp4

 ┣━30-8 商品列表页服务接口-2_ev[4][2].mp4

 ┣━30-7 商品列表页服务接口-1_ev[4][2].mp4

 ┣━30-3 物理删除还是逻辑删除_ev[4][2].mp4

 ┣━30-19 品牌分类相关接口_ev[4][2].mp4

 ┣━30-9 测试商品列表页_ev[4][2].mp4

 ┣━30-4 其余表结构定义和数据导入_ev[4][2].mp4

 ┣━30-5 定义proto文件_ev[4][2].mp4

 ┣━30-1 需求分析__ev[4][2].mp4

 ┣━30-6 商品服务器的启动_ev[4][2].mp4

 ┣━30-18 品牌相关接口_ev[4][2].mp4

 ┣━30-11 获取商品的详情和删除商品_ev[4][2].mp4

 ┣━第27章 服务集成注册中心

 ┣━27-3 将用户的grpc连接配置到全局共用 _[3].mp4

 ┣━27-1 srv服务集成consul _[3].mp4

 ┣━27-2 gin集成consul _[3].mp4

 ┣━第3章 基本数据类型、运算符和表达式

 ┣━3-4 strconv的parse类函数将字符串转换为其他类型 _[3].mp4

 ┣━3-1 go语言提供了哪些整数类_[3].mp4

 ┣━3-6 go语言运算符 _[3].mp4

 ┣━3-2 float类型和其它数据类型 _[3].mp4

 ┣━3-3 go语言最基本的数据类型转换 _[3].mp4

 ┣━3-5 python的基本数据类型转换 _[3].mp4

 ┣━第17章 protobuf和grpc进阶

 ┣━17-2 option gopackage的作用 _[3].mp4

 ┣━17-4 proto文件中引入其他的proto文件 _[3].mp4

 ┣━17-13 python实现grpc的拦截器 _[3].mp4

 ┣━17-5 嵌套的message对象 _[3].mp4

 ┣━17-3 当proto文件不同步的时候容易出现的问题 _[3].mp4

 ┣━17-8 使用protobuf内置的timestamp类型 _[3].mp4

 ┣━17-7 map类型 _[3].mp4

 ┣━17-15 grpc的验证器 _[3].mp4

 ┣━17-14 通过拦截器和metadata实现grpc的auth认证 _[3].mp4

 ┣━17-12 grpc拦截器 &#8211; go _[3].mp4

 ┣━17-10 grpc的metadata机制-go _[3].mp4

 ┣━17-1 protobuf的基本类型和默认值，python操作的坑 _[3].mp4

 ┣━17-17 grpc的超时机制 _[3].mp4

 ┣━17-6 protobuf中的enum枚举类型 _[3].mp4

 ┣━17-9 grpc配合asyncio使用 _[3].mp4

 ┣━17-16 grpc中的错误处理 _[3].mp4

 ┣━17-11 python操作metada _[3].mp4

 ┣━第14章 【阶段二：多语言通信基础 &#8211; grpc】14~17章内容

 ┣━14-7 基于zeromq的rpc框架 _[3].mp4

 ┣━14-2 什么是rpc？rpc开发的挑战是什么？- 2 _[3].mp4

 ┣━14-6 基于json的rpc技术 _[3].mp4

 ┣━14-3 使用httpserver实现rpc _[3].mp4

 ┣━14-1 什么是rpc？rpc开发的挑战是什么？-1 _[3].mp4

 ┣━14-5 基于xml的rpc库 _[3].mp4

 ┣━14-4 rpc的开发要素分析 _[3].mp4

 ┣━第1章 【阶段一：Go语言基础】1~13章内容试看

 ┣━1-5 xshell的安装和使用 _[3].mp4

 ┣━1-23 变量的作用域也有很多细节你可能没有在意 _[3].mp4

 ┣━1-18 go的hello world-1 _[3].mp4

 ┣━1-14 windows下安装nodejs开发环境 _[3].mp4

 ┣━1-16 代码提示神器 &#8211; kite的安装和配置 _[3].mp4

 ┣━1-22 常量的iota有什么用？ _[3].mp4

 ┣━1-8 mysql和navicat的安装和配置 _[3].mp4

 ┣━1-17 go语言介绍 _[3].mp4

 ┣━1-15 linxu下安装和配置nodejs开发环境 _[3].mp4

 ┣━1-21 go语言中的常量是什么？ _[3].mp4

 ┣━1-2 课程资源获取方式 &#8211; 非常重要！！！ _[3].mp4

 ┣━1-4 windows中安装centos7虚拟机 _[3].mp4

 ┣━1-6 git的安装和配置 _[3].mp4

 ┣━1-1 Go+Python双语言混合开发-课程导学 _[3].mp4

 ┣━1-10 python虚拟环境的安装和配置 _[3].mp4

 ┣━1-9 python的安装和配置 _[3].mp4

 ┣━1-13 linux下go开发环境搭建 _[3].mp4

 ┣━1-20 匿名变量是什么？ _[3].mp4

 ┣━1-11 pycharm的安装和配置 _[3].mp4

 ┣━1-12 windows下安装go和goland的配置 &#8211; 很重要！！ _[3].mp4

 ┣━1-7 docker和docker-compose的安装 _[3].mp4

 ┣━1-3 课程中需要用到的开发环境介绍 _[3].mp4

 ┣━1-19 变量的定义 _[3].mp4

 ┣━第26章 【阶段五：服务注册、服务发现、负载均衡、配置中心】26~29章内容

 ┣━26-1 什么是服务注册和发现以及技术选型 _[3].mp4

 ┣━26-6 第三方库实现服务注册 _[3].mp4

 ┣━26-5 配置grpc的健康检查 _[3].mp4

 ┣━26-7 go集成consul _[3].mp4

 ┣━26-4 服务注册的健康检查 _[3].mp4

 ┣━26-3 服务注册和注销 _[3].mp4

 ┣━26-2 consul的安装和配置 _[3].mp4

 ┣━第21章 python的orm-peewee

 ┣━21-4 多条插入、 or查询 _[3].mp4

 ┣━21-2 peewee的安装和入门 &#8211; 2 _[3].mp4

 ┣━资料__.7z

 ┣━21-7 多表查询和反向查询 _[3].mp4

 ┣━21-5 模糊查询、字典展示、排序、limit和去重 _[3].mp4

 ┣━21-1 peewee的安装和入门-1 _[3].mp4

 ┣━21-8 避免n加1查询问题 _[3].mp4

 ┣━21-6 聚合函数、执行原生的sql语句 _[3].mp4

 ┣━21-3 数据的更新和删除 _[3].mp4

 ┣━第34章 分布式锁

 ┣━34-5 基于setnx确保分布式锁的原子性_ev[4][2].mp4

 ┣━34-2 什么是分布式锁_ev[4][2].mp4

 ┣━34-3 基于mysql的乐观锁机制实现_ev[4][2].mp4

 ┣━34-4 redis分布式锁实现的基本原理_ev[4][2].mp4

 ┣━34-8 集成redis分布式锁到库存服务_ev[4][2].mp4

 ┣━34-9 基于redis的分布式锁的优缺点和其他的分布式锁实现方案_ev[4][2].mp4

 ┣━34-7 py-redis-lock核心源码分析_ev[4][2].mp4

 ┣━34-6 如何解决分布式锁中的重点难题_ev[4][2].mp4

 ┣━34-1 订单超卖问题是如何产生的？_ev[4][2].mp4

 ┣━第28章 负载均衡

 ┣━28-5 grpc从consul中同步服务信息并进行负载均衡-2 _[3].mp4

 ┣━28-4 grpc从consul中同步服务信息并进行负载均衡-1 _[3].mp4

 ┣━28-2 什么是负载均衡，负载均衡的策略有哪些？ _[3].mp4

 ┣━28-6 gin集成grpc的负载均衡 _[3].mp4

 ┣━28-3 常用负载均衡算法 _[3].mp4

 ┣━28-1 动态获取可用端口 _[3].mp4

 ┣━第5章 字符串的基本操作

 ┣━5-3 子串查询、子串统计、开始和结尾判断 _[3].mp4

 ┣━5-1 为什么len函数获取中文字符串长度有问题？ _[3].mp4

 ┣━5-2 什么是转义符？ _[3].mp4

 ┣━5-5 格式化的输入和输出 _[3].mp4

 ┣━5-4 子串的替换、连接和分割 _[3].mp4

 ┣━第20章 yapi的安装和配置

 ┣━20-3 yapi的安装和配置 _[3].mp4

 ┣━20-4 yapi基本功能使用 _[3].mp4

 ┣━20-2 接口文档管理之痛 _[3].mp4

 ┣━20-1 前后端分离的系统开发演变过程 _[3].mp4

 ┣━20-5 接口的导入和导出 _[3].mp4

 ┣━第25章 web层开发-用户接口开发

 ┣━25-4 session机制在微服务下的问题 _[3].mp4

 ┣━25-6 集成jwt到gin中 _[3].mp4

 ┣━25-9 获取图片验证码 _[3].mp4

 ┣━25-8 如何解决前后端的跨域问题 _[3].mp4

 ┣━25-7 给url添加登录权限验证 _[3].mp4

 ┣━25-5 json web token的认证机制 _[3].mp4

 ┣━25-12 用户注册接口 _[3].mp4

 ┣━25-2 自定义mobile验证器 _[3].mp4

 ┣━25-10 阿里云发送短信 _[3].mp4

 ┣━25-3 登录逻辑完善 _[3].mp4

 ┣━25-11 redis保存验证码 _[3].mp4

 ┣━25-1 表单验证的初始化 _[3].mp4

 ┣━第37章 用户操作服务-service层

 ┣━37-5 gin集成支付宝支付_3_ev[4][2].mp4

 ┣━37-6 支付宝回调通知url逻辑接口_ev[4][2].mp4

 ┣━37-3 支付宝的公钥、私钥和回调url配置_ev[4][2].mp4

 ┣━37-4 生成支付宝的支付url_ev[4][2].mp4

 ┣━37-2 私钥、公钥的概念以及支付宝如何解决订单的安全性问题_ev[4][2].mp4

 ┣━37-1 支付宝沙箱环境开发流程_ev[4][2].mp4

 ┣━第29章 配置中心

 ┣━29-4 nacos的组、配置集、命名空间 _[3].mp4

 ┣━29-5 python操作nacos配置 _[3].mp4

 ┣━29-8 gin集成nacos _[3].mp4

 ┣━29-7 go操作nacos _[3].mp4

 ┣━29-1 为什么需要配置中心 _[3].mp4

 ┣━29-2 配置中心选型-apollo vs nacos _[3].mp4

 ┣━29-6 service层集成nacos _[3].mp4

 ┣━29-3 nacos的安装 _[3].mp4

 ┣━第44章 实现基于可靠消息最终一致性的事务解决库存归还

 ┣━44-4 订单新建前的事务消息准备_ev[4][2].mp4

 ┣━44-5 基于回调实现消息的通信_ev[4][2].mp4

 ┣━44-11 启动所有微服务的注意事项_ev[4][2].mp4

 ┣━44-8 库存服务监听rocketmq消息_ev[4][2].mp4

 ┣━44-12 测试分布式事务一致性_ev[4][2].mp4

 ┣━44-3 库存扣减在分布式事务中的特殊性_ev[4][2].mp4

 ┣━44-14 订单新建成功后发送延时消息_ev[4][2].mp4

 ┣━44-9 库存扣减记录下扣减历史_ev[4][2].mp4

 ┣━44-2 订单新建的过程中如果保证库存数据的最终一致性_ev[4][2].mp4

 ┣━44-16 测试库存的超时归还_ev[4][2].mp4

 ┣━44-1 开始之前的网络问题 &#8211; 重要！！！_ev[4][2].mp4

 ┣━44-6 什么时候应该对事务消息进行确认？_ev[4][2].mp4

 ┣━44-7 库存扣减事务的完善_ev[4][2].mp4

 ┣━44-13 订单超时归还的流程分析_ev[4][2].mp4

 ┣━44-15 订单超时后的库存归还实现_ev[4][2].mp4

 ┣━44-10 库存归还的细节处理_ev[4][2].mp4

 ┣━第2章 计算机组成原理快速扫盲

 ┣━2-2 二进制、八进制和十六进制 _[3].mp4

 ┣━2-1 为什么我们要学习计算机组成原理 _[3].mp4

 ┣━2-3 ascii码表是什么？ _[3].mp4

 ┣━第51章 kong的基本功能

 ┣━51-5 kong配置jwt实现登录校验 (1611).mp4

 ┣━51-1 kong的8001、800和1337端口号的关系 (0803)_ev[2].mp4

 ┣━51-5 kong配置jwt实现登录校验 (1611)[4].mp4

 ┣━51-2 基本的路由转发配置 (0947)_ev[2].mp4

 ┣━51-2 基本的路由转发配置.mp4

 ┣━51-3 kong的service、routes、upstream的请求过程 (0622)[2].mp4

 ┣━51-1 kong的8001、800和1337端口号的关系.mp4

 ┣━51-5 kong配置jwt实现登录校验.mp4

 ┣━51-4 kong集成consul实现服务发现和负载均衡.mp4

 ┣━51-5 kong配置jwt实现登录校验 (1611).avi

 ┣━51-3 kong的service、routes、upstream的请求过程 (0622)[4][2].mp4

 ┣━51-1 kong的8001、800和1337端口号的关系 (0803)_ev[4].mp4

 ┣━51-6 kong配置反爬和ip黑名单.mp4

 ┣━51-3 kong的service、routes、upstream的请求过程.mp4

 ┣━51-4 kong集成consul实现服务发现和负载均衡 (0705).avi

 ┣━51-2 基本的路由转发配置 (0947)_ev[4].mp4

 ┣━51-4 kong集成consul实现服务发现和负载均衡 (0705).mp4

 ┣━51-4 kong集成consul实现服务发现和负载均衡 (0705)[4].mp4

 ┣━第18章 【阶段三：需求分析、架构设计、orm和web框架基础】18~22章内容

 ┣━18-3 电商系统需求分析 _[3].mp4

 ┣━18-2 后台管理系统需求 _[3].mp4

 ┣━微信二维码_.png

 ┣━18-1 如何启动电商系统和后台管理系统 _[3].mp4

 ┣━第38章 用户操作服务-web等

 ┣━38-7 调试收藏、收货地址、留言接口_ev[4][2].mp4

 ┣━38-2 proto接口定义_ev[4][2].mp4

 ┣━38-6 解读handler的代码_ev[4][2].mp4

 ┣━38-3 运行用户操作服务_ev[4][2].mp4

 ┣━38-5 web服务启动_ev[4][2].mp4

 ┣━38-4 handler的代码解读_ev[4][2].mp4

 ┣━38-1 需求分析和表结构定义_ev[4][2].mp4

 ┣━第23章 【第四阶段：第一个微服务 &#8211; 用户服务】23~25章内容

 ┣━23-4 md5盐值加密解决用户密码安全问题 _[3].mp4

 ┣━资料__.7z

 ┣━23-3 md5信息摘要 _[3].mp4

 ┣━23-6 用户列表接口 _[3].mp4

 ┣━23-11 通过id和mobile查询用户是否存在 _[3].mp4

 ┣━23-2 user表结构设计和生成 _[3].mp4

 ┣━23-1 新建虚拟环境和项目 _[3].mp4

 ┣━23-5 proto接口定义和生成 _[3].mp4

 ┣━23-13 更新用户 _[3].mp4

 ┣━23-7 启动grpc服务 _[3].mp4

 ┣━23-12 新建用户接口 _[3].mp4

 ┣━23-10 通过argparse解析传递进入的参数 _[3].mp4

 ┣━23-8 日志库选型 &#8211; loguru _[3].mp4

 ┣━23-9 优雅退出server _[3].mp4

 ┣━第16章 grpc快速入门

 ┣━16-3 python体验grpc开发 _[3].mp4

 ┣━16-5 go下grpc快速体验 &#8211; 1 _[3].mp4

 ┣━16-1 什么是grpc和protobuf _[3].mp4

 ┣━16-6 go下grpc快速体验-2 _[3].mp4

 ┣━16-4 python下生产的grpc文件import路径有问题的探讨 _[3].mp4

 ┣━16-2 python下体验protobuf _[3].mp4

 ┣━16-8 grpc的流模式的定义 _[3].mp4

 ┣━16-7 go和python互相调用 _[3].mp4

 ┣━16-9 grpc的单向流，双向流代码实现 _[3].mp4

 ┣━第41章 分布式理论基础和常见的分布式事务解决方案

 ┣━41-8 最大努力通知方案_ev[4][2].mp4

 ┣━41-6 基于本地消息的最终一致性方案_ev[4][2].mp4

 ┣━41-1 cap理论_ev[4][2].mp4

 ┣━41-4 TCC分布式事务实现方案_ev[4][2].mp4

 ┣━41-5 TCC分布式事务实现方案-2_ev[4][2].mp4

 ┣━41-7 基于可靠消息的最终一致性_ev[4][2].mp4

 ┣━41-2 BASE理论_ev[4][2].mp4

 ┣━41-3 2pc两阶段提交分布式事务_ev[4][2].mp4

 ┣━第24章 web层开发-gin基础项目架构

 ┣━资料__.7z

 ┣━24-4 集成zap和理由初始到gin的启动过程 &#8211; 1 _[3].mp4

 ┣━24-2 go高性能日志库 &#8211; zap使用 _[3].mp4

 ┣━24-10 viper集成到gin的web服务中 _[3].mp4

 ┣━24-7 gin调用grpc服务-2 _[3].mp4

 ┣━24-3 zap的文件输出 _[3].mp4

 ┣━24-5 集成zap和理由初始到gin的启动过程-2 _[3].mp4

 ┣━24-6 gin调用grpc服务-1 _[3].mp4

 ┣━24-9 viper的配置环境开发环境和生产环境隔离 _[3].mp4

 ┣━24-1 新建项目和目录结构构建 _[3].mp4

 ┣━24-8 配置文件 &#8211; viper _[3].mp4

 ┣━第50章 【阶段九：API网关】49~50章内容

 ┣━50-2 api网关具备的功能有哪些？_ev[4][2].mp4

 ┣━50-1 什么是api网关_ev[4][2].mp4

 ┣━50-3 api网关技术选型_ev[4][2].mp4

 ┣━50-4 kong的安装_ev[4][2].mp4

 ┣━第32章 阿里云的oss服务

 ┣━32-8 将oss集成到gin微服务中_ev[4][2].mp4

 ┣━32-2 oss的基本概念介绍_ev[4][2].mp4

 ┣━32-4 前端直传oss的流程_ev[4][2].mp4

 ┣━32-3 使用代码控制文件上传_ev[4][2].mp4

 ┣━32-7 内网穿透技术解决前端直传的回调_ev[4][2].mp4

 ┣━32-6 为什么我们需要内网穿透_ev[4][2].mp4

 ┣━32-5 gin集成前端直传文件_ev[4][2].mp4

 ┣━32-1 为什么要使用阿里云oss_ev[4][2].mp4

 ┣━第53章 jekins自动化部署

 ┣━53-2 前端代码上传到git并启动_ev[4][2].mp4

 ┣━53-6 通过shell脚本启动gin服务_ev[4][2].mp4

 ┣━53-3 nginx中部署vuejs_ev[4][2].mp4

 ┣━53-1 有哪些服务器我们需要部署？_ev[4][2].mp4

 ┣━53-7 构建和部署python微服务-1_ev[4][2].mp4

 ┣━53-5 发布go项目到远程服务器上_ev[4][2].mp4

 ┣━53-4 jenkens部署vuejs项目_ev[4][2].mp4

 ┣━53-8 构建和部署python微服务-2_ev[4][2].mp4

 ┣━第48章 gin和python集成jaeger

 ┣━48-3 gin中添加拦截器实现jaeger注入_ev[4][2].mp4

 ┣━48-2 go下通过grpc发送span消息_ev[4][2].mp4

 ┣━48-4 修改grpc_opentracing源码_ev[4][2].mp4

 ┣━48-5 配置订单服务的web层逻辑_ev[4][2].mp4

 ┣━48-1 go发送简单的span消息_ev[4][2].mp4

 ┣━48-6 订单服务的service链路追踪实现_ev[4][2].mp4

 ┣━资料与代码

 ┣━代码资料.zip

 ┣━第8章 go语言的利器- 指针

 ┣━8-3 make函数和new函数 _[3].mp4

 ┣━8-1 什么是指针 _[3].mp4

 ┣━8-5 go语言中的nil和python中的None有什么区别？ _[3].mp4

 ┣━8-2 go的指针和c语言的指针有什么区别？ _[3].mp4

 ┣━8-4 图解new函数的执行过程 _[3].mp4

 ┣━第31章 商品服务-web等

 ┣━31-5 gin的退出后的服务注销_ev[4][2].mp4

 ┣━31-10 商品分类的接口_ev[4][2].mp4

 ┣━31-11 轮播图接口和yapi的快速测试_ev[4][2].mp4

 ┣━31-2 商品的列表页接口-1_ev[4][2].mp4

 ┣━31-13 品牌分类接口_ev[4][2].mp4

 ┣━31-6 用户的web服务服务注册和优雅退出_ev[4][2].mp4

 ┣━31-1 快速将用户的web服务转换成商品的web服务_ev[4][2].mp4

 ┣━31-7 新建商品_ev[4][2].mp4

 ┣━31-12 品牌和品牌分类接口 （proto同步脚本）_ev[4][2].mp4

 ┣━31-3 商品的列表页接口-2_ev[4][2].mp4

 ┣━31-8 获取商品详情_ev[4][2].mp4

 ┣━31-9 商品删除，更新_ev[4][2].mp4

 ┣━31-4 如何设计一个符合go风格的注册中心接口_ev[4][2].mp4

 ┣━第47章 第二章 链路追踪open tracing和jaeger

 ┣━47-2 发送多级调用的span消息_ev[4][2].mp4

 ┣━47-4 grpc下client_interceptor的源码解读_ev[4][2].mp4

 ┣━47-5 grpc下server端发送span消息_ev[4][2].mp4

 ┣━47-7 在grpc的server端添加子链路_ev[4][2].mp4

 ┣━47-6 grpc下server_interceptor的源码解读_ev[4][2].mp4

 ┣━47-3 grpc下发送span消息_ev[4][2].mp4

 ┣━47-1 python发送单个span_ev[4][2].mp4

 ┣━第22章 go的web框架-gin

 ┣━22-10 表单中文翻译的json格式化细节 _[3].mp4

 ┣━22-7 登录的表单验证 _[3].mp4

 ┣━22-9 表单验证错误翻译成中文 _[3].mp4

 ┣━22-14 gin返回html _[3].mp4

 ┣━22-8 注册表单的验证 _[3].mp4

 ┣━22-13 gin的中间件原理源码分析 _[3].mp4

 ┣━22-6 gin返回protobuf _[3].mp4

 ┣━22-2 使用New和Default初始化路由器的区别 _[3].mp4

 ┣━22-4 获取url中的变量 _[3].mp4

 ┣━22-12 通过abort终止中间件后续逻辑的执行 _[3].mp4

 ┣━22-16 static静态文件的处理 _[3].mp4

 ┣━22-3 gin的路由分组 _[3].mp4

 ┣━22-15 加载多个html文件 _[3].mp4

 ┣━22-11 自定义gin中间件 _[3].mp4

 ┣━22-1 gin的helloworld体验 _[3].mp4

 ┣━22-17 gin的优雅退出 _[3].mp4

 ┣━资料__.7z

 ┣━22-5 获取get和post表单信息 _[3].mp4

 ┣━第6章 条件语句和循环语句

 ┣━6-4 goto语句能帮我们完成什么功能？ _[3].mp4

 ┣━6-6 python中如何实现switch的效果？ _[3].mp4

 ┣━6-3 go语言的for range用法 _[3].mp4

 ┣━6-2 go语言的for循环 _[3].mp4

 ┣━6-5 switch语句能让代码可读性更高 _[3].mp4

 ┣━6-1 if条件控制语句 _[3].mp4

 ┣━第9章 go语言的函数

 ┣━9-2 通过省略号设置参数个数不定长 _[3].mp4

 ┣━9-3 go语言中的函数是一等公民 _[3].mp4

 ┣━9-1 函数的各种定义 _[3].mp4

 ┣━9-8 panic和recover的坑 _[3].mp4

 ┣━9-4 python中的finally的执行顺序你真的弄懂了吗？ _[3].mp4

 ┣━9-6 defer机制你忽略了很多细节 _[3].mp4

 ┣━9-7 python是如何处理代码错误和异常的？ _[3].mp4

 ┣━资料__.7z

 ┣━9-5 defer的作用和多个defer的执行顺序 _[3].mp4

 ┣━第42章 消息队列在微服务中的作用和选型

 ┣━42-2 mq消息队列技术选型mp4_ev[4][2].mp4

 ┣━42-1 mq的应用场景mp4_ev[4][2].mp4

 ┣━第39章 前后端联调

 ┣━39-3 商品列表页分析_ev[4][2].mp4

 ┣━39-7 后台管理系统-商品列表页_ev[4][2].mp4

 ┣━39-5 前端文件直传的源码解析_ev[4][2].mp4

 ┣━39-6 用户详情和更新接口_ev[4][2].mp4

 ┣━39-1 启动online-store服务_ev[4][2].mp4

 ┣━39-2 首页接口的请求分析_ev[4][2].mp4

 ┣━39-4 个人中心、订单相关功能联调_ev[4][2].mp4

 ┣━第49章 熔断、限流 &#8211; sentinel

 ┣━49-10 python下集成CircuitBreaker_ev[4][2].mp4

 ┣━49-6 sentinel的熔断接口_ev[4][2].mp4

 ┣━49-4 sentinel的预热和冷启动_ev[4][2].mp4

 ┣━49-5 sentinel的Throttling配置策略_ev[4][2].mp4

 ┣━49-3 sentinel的qps限流_ev[4][2].mp4

 ┣━49-2 sentinel和hystrix对比_ev[4][2].mp4

 ┣━49-7 sentinel的熔断接口-基于错误数_ev[4][2].mp4

 ┣━49-1 什么是限流、熔断和降级_ev[4][2].mp4

 ┣━49-8 sentinel的熔断接口-基于错误率和慢请求_ev[4][2].mp4

 ┣━49-11 python下使用ratelitmit进行限流_ev[4][2].mp4

 ┣━49-9 gin集成sentinel实现限流_ev[4][2].mp4

 ┣━第13章 go并发编程

 ┣━13-9 使用channel容易出现deadlock的原因 _[3].mp4

 ┣━13-8 双向和单向的channel _[3].mp4

 ┣━13-6 通过channel进行goroutine间的通信 _[3].mp4

 ┣━13-3 使用waitgroup控制协程退出 _[3].mp4

 ┣━13-12 通过context控制超时 _[3].mp4

 ┣━13-4 使用互斥锁同步协程 _[3].mp4

 ┣━13-11 context的应用场景 _[3].mp4

 ┣━13-2 go的协程和python协程对比 _[3].mp4

 ┣━13-10 go中select的应用场景 _[3].mp4

 ┣━13-7 通过for range遍历channel和close关闭channel _[3].mp4

 ┣━13-5 使用RWMutex锁同步协程 _[3].mp4

 ┣━13-1 go的goroutine _[3].mp4

 ┣━第4章 python的海象运算符和变量注解

 ┣━4-3 python如何强制检查函数的参数类型 _[3].mp4

 ┣━4-1 python3.8的新特性-海象运算符 _[3].mp4

 ┣━4-2 python的变量居然也能申明类型！ _[3].mp4

 ┣━第12章 包管理和编码规范

 ┣━12-1 如何使用go modules _[3].mp4

 ┣━12-3 go的import的各种姿势 _[3].mp4

 ┣━12-2 go的包和python的包区别 _[3].mp4

 ┣━12-4 package和init函数的关系 _[3].mp4

 ┣━12-5 gopath开发模式和go modules开发模式对比 _[3].mp4

 ┣━12-7 go编码规范 &#8211; 2 _[3].mp4

 ┣━12-8 python编码规范 _[3].mp4

 ┣━12-6 go编码规范-1 _[3].mp4

 ┣━第15章 go的rpc体验

 ┣━15-5 进一步改造rpc调用的代码-2 _[3].mp4

 ┣━15-3 替换rpc的传输协议为http _[3].mp4

 ┣━15-1 go快速体验rpc开发 _[3].mp4

 ┣━15-4 进一步改造rpc调用的代码-1 _[3].mp4

 ┣━15-2 替换rpc的序列化协议为json _[3].mp4

 ┣━第33章 库存服务

 ┣━33-2 库存服务表结构设计_ev[4][2].mp4

 ┣━33-6 库存的扣减和事务_ev[4][2].mp4

 ┣━33-1 库存服务的重要性_ev[4][2].mp4

 ┣━33-4 配置启动库存服务_ev[4][2].mp4

 ┣━33-5 设置库存和获取库存详情_ev[4][2].mp4

 ┣━33-7 库存归还_ev[4][2].mp4

 ┣━33-3 proto接口设计_ev[4][2].mp4

 ┣━33-8 测试库存服务接口_ev[4][2].mp4

 ┣━33-9 为所有的商品添加库存信息_ev[4][2].mp4

  