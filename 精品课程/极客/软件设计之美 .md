# 软件设计之美  

## 联系方式

客服微信号：itziyuan_xiaozhi

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/common/20240614073449/666b82192834a.jpg" width="200" height="200" alt="二维码">

## 课程简介

下载链接：https://it.bcwex.shop/posts?id=2181

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/yun/20240515183717/6644905d3f06b.jpg" width="500" alt="">

  多一点设计，少一点问题

 3 个步骤，理解优秀软件的设计

 典型的软件设计思维误区及解析

 设计软件必备的 4 大知识模块

 30+ 案例，深入剖析软件设计本质

 课程主体分为四个模块。

 第一模块：课前必读

 在正式开始软件设计的学习之前，我们会先梳理清楚软件设计的真正内涵与意义，与你谈谈影响软件设计的两个不可忽视的因素：分离关注点和可测试性。掌握这些内容会为你的软件设计学习之旅奠定一个良好的基础。

 第二模块：了解一个软件的设计

 教你一个“三步走”方法，让你无论是在新接触一个项目，或是想借鉴优秀实践的设计时，都有可以遵循的框架，快速抓到一个软件的设计精髓。同时，我们还会深入拆解三个最具代表性的开源项目，让你在案例中加深对知识的理解。

 第三模块：设计一个软件

 给你讲解设计一个软件时，你需要掌握的核心知识：

  程序设计语言：横跨语言学语言，让你不再局限于某一种语言，而是根据应用场景，择其善者而从之； 编程范式：选择了几个最主流的编程范式，包括结构化编程、面向对象和函数式编程，帮你建立起软件设计的根基； 设计原则与模式：给你介绍面向对象的主流设计原则，SOLID 原则。还会分享一些学习设计模式的心得，帮助你将设计模式的相关知识贯穿起来； 设计方法：分析 DDD 设计方法，这是当下完整、有效的应对复杂业务场景的设计方法，包括了从如何识别概念到如何建立模型。  第四模块：巩固篇

 通过三个实战项目，分析如何设计一个程序库、如何构建一个可扩展的模型和如何对既有的项目做设计上的改进，将学到的软件知识融会贯通。

 〖课程截图〗:

  ├──jk52601-软件设计之美

 | ├──00-开篇词 (1讲)

 | | ├──00丨开篇词丨软件设计，应对需求规模的“算法”.html 4.18M

 | | ├──00丨开篇词丨软件设计，应对需求规模的“算法”.m4a 8.40M

 | | └──00丨开篇词丨软件设计，应对需求规模的“算法”.pdf 6.15M

 | ├──01-课前必读 (3讲)

 | | ├──01丨软件设计到底是什么？.html 5.14M

 | | ├──01丨软件设计到底是什么？.m4a 9.43M

 | | ├──01丨软件设计到底是什么？.pdf 3.45M

 | | ├──02丨分离关注点：软件设计至关重要的第一步.html 2.51M

 | | ├──02丨分离关注点：软件设计至关重要的第一步.m4a 8.30M

 | | ├──02丨分离关注点：软件设计至关重要的第一步.pdf 2.03M

 | | ├──03丨可测试性：一个影响软件设计的重要因素.html 2.85M

 | | ├──03丨可测试性：一个影响软件设计的重要因素.m4a 9.12M

 | | └──03丨可测试性：一个影响软件设计的重要因素.pdf 1.93M

 | ├──02-了解一个软件的设计 (4讲)

 | | ├──04丨三步走：如何了解一个软件的设计？.html 2.89M

 | | ├──04丨三步走：如何了解一个软件的设计？.m4a 8.45M

 | | ├──04丨三步走：如何了解一个软件的设计？.pdf 2.19M

 | | ├──05丨Spring DI容器：如何分析一个软件的模型？.html 3.21M

 | | ├──05丨SpringDI容器：如何分析一个软件的模型？.m4a 10.23M

 | | ├──05丨SpringDI容器：如何分析一个软件的模型？.pdf 2.43M

 | | ├──06丨Ruby on Rails：如何分析一个软件的接口？.html 3.24M

 | | ├──06丨RubyonRails：如何分析一个软件的接口？.m4a 11.52M

 | | ├──06丨RubyonRails：如何分析一个软件的接口？.pdf 2.23M

 | | ├──07丨Kafka：如何分析一个软件的实现？.html 2.97M

 | | ├──07丨Kafka：如何分析一个软件的实现？.m4a 10.11M

 | | └──07丨Kafka：如何分析一个软件的实现？.pdf 1.99M

 | ├──03-设计一个软件—程序设计语言 (5讲)

 | | ├──08丨语言的模型：如何打破单一语言局限，让设计更好地落地？.html 2.84M

 | | ├──08丨语言的模型：如何打破单一语言局限，让设计更好地落地？.m4a 10.40M

 | | ├──08丨语言的模型：如何打破单一语言局限，让设计更好地落地？.pdf 2.10M

 | | ├──09丨语言的接口：语法和程序库，软件设计的发力点.html 2.73M

 | | ├──09丨语言的接口：语法和程序库，软件设计的发力点.m4a 8.87M

 | | ├──09丨语言的接口：语法和程序库，软件设计的发力点.pdf 2.02M

 | | ├──10丨语言的实现：运行时，软件设计的地基.html 2.44M

 | | ├──10丨语言的实现：运行时，软件设计的地基.m4a 8.56M

 | | ├──10丨语言的实现：运行时，软件设计的地基.pdf 1.68M

 | | ├──11丨DSL：你也可以设计一门自己的语言.html 4.75M

 | | ├──11丨DSL：你也可以设计一门自己的语言.m4a 8.58M

 | | ├──11丨DSL：你也可以设计一门自己的语言.pdf 3.00M

 | | ├──加餐丨再八卦几门语言！.html 2.46M

 | | ├──加餐丨再八卦几门语言！.m4a 12.54M

 | | └──加餐丨再八卦几门语言！.pdf 2.00M

 | ├──04-设计一个软件—编程范式 (9讲)

 | | ├──12丨编程范式：明明写的是Java，为什么被人说成了C代码？.html 4.28M

 | | ├──12丨编程范式：明明写的是Java，为什么被人说成了C代码？.m4a 8.13M

 | | ├──12丨编程范式：明明写的是Java，为什么被人说成了C代码？.pdf 2.65M

 | | ├──13丨结构化编程：为什么做设计时仅有结构化编程是不够的？.html 2.68M

 | | ├──13丨结构化编程：为什么做设计时仅有结构化编程是不够的？.m4a 9.52M

 | | ├──13丨结构化编程：为什么做设计时仅有结构化编程是不够的？.pdf 1.88M

 | | ├──14丨面向对象之封装：怎样的封装才算是高内聚？.html 3.15M

 | | ├──14丨面向对象之封装：怎样的封装才算是高内聚？.m4a 9.60M

 | | ├──14丨面向对象之封装：怎样的封装才算是高内聚？.pdf 2.32M

 | | ├──15丨面向对象之继承：继承是代码复用的合理方式吗？.html 3.42M

 | | ├──15丨面向对象之继承：继承是代码复用的合理方式吗？.m4a 8.50M

 | | ├──15丨面向对象之继承：继承是代码复用的合理方式吗？.pdf 2.27M

 | | ├──16丨面向对象之多态：为什么“稀疏平常”的多态，是软件设计的大杀器？.html 3.15M

 | | ├──16丨面向对象之多态：为什么“稀疏平常”的多态，是软件设计的大杀器？.m4a 9.94M

 | | ├──16丨面向对象之多态：为什么“稀疏平常”的多态，是软件设计的大杀器？.pdf 2.23M

 | | ├──17丨函数式编程：不用函数式编程语言，怎么写函数式的程序？.html 5.12M

 | | ├──17丨函数式编程：不用函数式编程语言，怎么写函数式的程序？.m4a 9.69M

 | | ├──17丨函数式编程：不用函数式编程语言，怎么写函数式的程序？.pdf 2.90M

 | | ├──18丨函数式编程之组合性：函数式编程为什么如此吸引人？.html 3.65M

 | | ├──18丨函数式编程之组合性：函数式编程为什么如此吸引人？.m4a 10.75M

 | | ├──18丨函数式编程之组合性：函数式编程为什么如此吸引人？.pdf 2.47M

 | | ├──19丨函数式编程之不变性：怎样保证我的代码不会被别人破坏？.html 3.03M

 | | ├──19丨函数式编程之不变性：怎样保证我的代码不会被别人破坏？.m4a 9.86M

 | | ├──19丨函数式编程之不变性：怎样保证我的代码不会被别人破坏？.pdf 1.91M

 | | ├──加餐丨函数式编程拾遗.html 3.39M

 | | ├──加餐丨函数式编程拾遗.m4a 10.74M

 | | └──加餐丨函数式编程拾遗.pdf 2.12M

 | ├──05-设计一个软件—设计原则与模式 (7讲)

 | | ├──20丨单一职责原则：你的模块到底为谁负责？.html 4.74M

 | | ├──20丨单一职责原则：你的模块到底为谁负责？.m4a 9.47M

 | | ├──20丨单一职责原则：你的模块到底为谁负责？.pdf 2.58M

 | | ├──21丨开放封闭原则：不改代码怎么写新功能？.html 3.23M

 | | ├──21丨开放封闭原则：不改代码怎么写新功能？.m4a 8.67M

 | | ├──21丨开放封闭原则：不改代码怎么写新功能？.pdf 1.88M

 | | ├──22丨Liskov替换原则：用了继承，子类就设计对了吗？.html 3.68M

 | | ├──22丨Liskov替换原则：用了继承，子类就设计对了吗？.m4a 10.27M

 | | ├──22丨Liskov替换原则：用了继承，子类就设计对了吗？.pdf 2.15M

 | | ├──23丨接口隔离原则：接口里的方法，你都用得到吗？.html 2.93M

 | | ├──23丨接口隔离原则：接口里的方法，你都用得到吗？.m4a 10.34M

 | | ├──23丨接口隔离原则：接口里的方法，你都用得到吗？.pdf 2.15M

 | | ├──24丨依赖倒置原则：高层代码和底层代码，到底谁该依赖谁？.html 3.07M

 | | ├──24丨依赖倒置原则：高层代码和底层代码，到底谁该依赖谁？.m4a 9.88M

 | | ├──24丨依赖倒置原则：高层代码和底层代码，到底谁该依赖谁？.pdf 2.19M

 | | ├──25丨设计模式：每一种都是一个特定问题的解决方案.html 4.20M

 | | ├──25丨设计模式：每一种都是一个特定问题的解决方案.m4a 9.57M

 | | ├──25丨设计模式：每一种都是一个特定问题的解决方案.pdf 2.37M

 | | ├──26丨简单设计：难道一开始就要把设计做复杂吗？.html 3.82M

 | | ├──26丨简单设计：难道一开始就要把设计做复杂吗？.m4a 9.72M

 | | └──26丨简单设计：难道一开始就要把设计做复杂吗？.pdf 2.37M

 | ├──06-设计一个软件—设计方法 (3讲)

 | | ├──27丨领域驱动设计：如何从零开始设计一个软件？.html 2.73M

 | | ├──27丨领域驱动设计：如何从零开始设计一个软件？.m4a 9.80M

 | | ├──27丨领域驱动设计：如何从零开始设计一个软件？.pdf 1.97M

 | | ├──28丨战略设计：如何划分系统的模块？.html 4.83M

 | | ├──28丨战略设计：如何划分系统的模块？.m4a 9.03M

 | | ├──28丨战略设计：如何划分系统的模块？.pdf 2.90M

 | | ├──29丨战术设计：如何像写故事一样找出模型？.html 4.93M

 | | ├──29丨战术设计：如何像写故事一样找出模型？.m4a 12.24M

 | | └──29丨战术设计：如何像写故事一样找出模型？.pdf 2.85M

 | ├──07-巩固篇 (3讲)

 | | ├──30丨程序库的设计：Moco是如何解决集成问题的？.html 3.20M

 | | ├──30丨程序库的设计：Moco是如何解决集成问题的？.m4a 11.85M

 | | ├──30丨程序库的设计：Moco是如何解决集成问题的？.pdf 1.93M

 | | ├──31丨应用的设计：如何设计一个数据采集平台？.html 3.57M

 | | ├──31丨应用的设计：如何设计一个数据采集平台？.m4a 10.70M

 | | ├──31丨应用的设计：如何设计一个数据采集平台？.pdf 2.44M

 | | ├──32丨应用的改进：如何改进我们的软件设计？.html 3.15M

 | | ├──32丨应用的改进：如何改进我们的软件设计？.m4a 8.75M

 | | └──32丨应用的改进：如何改进我们的软件设计？.pdf 1.94M

 | └──08-结束语 (1讲)

  