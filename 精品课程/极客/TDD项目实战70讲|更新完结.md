# TDD 项目实战 70 讲 | 更新完结

## 联系方式

客服微信号：itziyuan_xiaozhi

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/common/20240614073449/666b82192834a.jpg" width="200" height="200" alt="二维码">

## 课程简介

下载链接：https://it.bcwex.shop/posts?id=2360

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/yun/20240515183850/664490bae1486.jpg" width="500" alt="">

  

 课程主体可分为两个部分。

 第一部分：演示开发全过程，见识真正的 TDD

 首先，我们将从一个编码练习级别的小例子入手，展示使用 TDD 的方式来实现一个简单功能的开发全过程。让你眼见为实，对 TDD 形成一个感性、直观的认识。

 并以此为引子，串联起 TDD 的所有相关知识点，为之后的实战练习打下基础。同时，你也会明确知道 TDD 作为工程方法的核心优势在哪里。如果你需要说服周围的同事、领导开始采用 TDD 方法，这将给你提供足够的弹药。

 第二部分：实战细节全剖析，用 TDD 从头实现

 然后，我们将进入实战项目环节。老师将以 3 个技术框架为例（IoC 容器、RESTful 框架、SQL mapper 框架），展示如何使用 TDD 的方式从头来实现它们，实战的细节将一览无遗。

 TDD 有点像物理，定理写出来很简单，但需要在不同的场景下练习，才能应用得得心应手。所以，你会在这个部分看到 3 个实战项目，将会有 40+ 小时的视频演示。由徐昊老师在不同的上下文中带着你反复练习，帮助你搞定 TDD 的落地难题。

 〖资源截图〗:

 TDD 项目实战 70 讲

 〖资源目录〗:

 – ├──01｜TDD演示（1）：任务分解法与整体工作流程.md 6.23kb

 – ├──01｜TDD演示（1）：任务分解法与整体工作流程.mp3 5.82M

 – ├──01｜TDD演示（1）：任务分解法与整体工作流程.pdf 4.38M

 – ├──02｜TDD演示（2）：识别坏味道与代码重构.md 7.54kb

 – ├──02｜TDD演示（2）：识别坏味道与代码重构.mp3 4.79M

 – ├──02｜TDD演示（2）：识别坏味道与代码重构.pdf 3.34M

 – ├──03｜TDD演示（3）：按测试策略重组测试.md 6.99kb

 – ├──03｜TDD演示（3）：按测试策略重组测试.mp3 5.98M

 – ├──03｜TDD演示（3）：按测试策略重组测试.pdf 3.68M

 – ├──04｜TDD演示（4）：实现对于列表参数的支持.md 6.57kb

 – ├──04｜TDD演示（4）：实现对于列表参数的支持.mp3 6.55M

 – ├──04｜TDD演示（4）：实现对于列表参数的支持.pdf 2.58M

 – ├──05｜TDD中的测试（1）：状态验证为什么是主要的使用方式？.md 6.58kb

 – ├──05｜TDD中的测试（1）：状态验证为什么是主要的使用方式？.mp3 7.15M

 – ├──05｜TDD中的测试（1）：状态验证为什么是主要的使用方式？.pdf 3.46M

 – ├──06｜TDD中的测试（2）：行为验证为什么应该尽量避免使用？.md 7.42kb

 – ├──06｜TDD中的测试（2）：行为验证为什么应该尽量避免使用？.mp3 8.77M

 – ├──06｜TDD中的测试（2）：行为验证为什么应该尽量避免使用？.pdf 3.33M

 – ├──07｜TDD中的测试（3）：集成测试还是单元测试？.md 8.17kb

 – ├──07｜TDD中的测试（3）：集成测试还是单元测试？.mp3 7.67M

 – ├──07｜TDD中的测试（3）：集成测试还是单元测试？.pdf 2.15M

 – ├──08｜TDD中的驱动（1）：驱动的极限是什么？.md 7.96kb

 – ├──08｜TDD中的驱动（1）：驱动的极限是什么？.mp3 6.65M

 – ├──08｜TDD中的驱动（1）：驱动的极限是什么？.pdf 2.83M

 – ├──09｜TDD中的驱动（2）：重构发挥了什么作用？.md 6.19kb

 – ├──09｜TDD中的驱动（2）：重构发挥了什么作用？.mp3 5.67M

 – ├──09｜TDD中的驱动（2）：重构发挥了什么作用？.pdf 4.05M

 – ├──10｜TDD中的驱动（3）：何为经典学派？何为伦敦学派？.md 6.06kb

 – ├──10｜TDD中的驱动（3）：何为经典学派？何为伦敦学派？.mp3 5.04M

 – ├──10｜TDD中的驱动（3）：何为经典学派？何为伦敦学派？.pdf 2.02M

 – ├──11｜作为工程化方法的TDD：更低的成本与更高的效能.md 9.80kb

 – ├──11｜作为工程化方法的TDD：更低的成本与更高的效能.mp3 8.24M

 – ├──11｜作为工程化方法的TDD：更低的成本与更高的效能.pdf 3.39M

 – ├──12｜实战中的TDD：RESTfulAPI的开发框架.md 3.09kb

 – ├──12｜实战中的TDD：RESTfulAPI的开发框架.mp3 2.61M

 – ├──12｜实战中的TDD：RESTfulAPI的开发框架.pdf 2.65M

 – ├──13｜DIContainer（1）：如何实现基本的DI容器结构？.md 4.46kb

 – ├──13｜DIContainer（1）：如何实现基本的DI容器结构？.mp3 2.11M

 – ├──13｜DIContainer（1）：如何实现基本的DI容器结构？.pdf 2.08M

 – ├──14｜DIContainer（2）：如何通过SadPath为容器增加功能？.md 3.36kb

 – ├──14｜DIContainer（2）：如何通过SadPath为容器增加功能？.mp3 1.13M

 – ├──14｜DIContainer（2）：如何通过SadPath为容器增加功能？.pdf 2.28M

 – ├──15｜DIContainer（3）：如何重构已有的代码？.md 4.67kb

 – ├──15｜DIContainer（3）：如何重构已有的代码？.mp3 1.26M

 – ├──15｜DIContainer（3）：如何重构已有的代码？.pdf 2.35M

 – ├──16｜DIContainer（4）：如何实现对循环依赖的处理？.md 3.09kb

 – ├──16｜DIContainer（4）：如何实现对循环依赖的处理？.mp3 1.87M

 – ├──16｜DIContainer（4）：如何实现对循环依赖的处理？.pdf 3.17M

 – ├──17｜DIContainer（5）：API接口该怎么设计？.md 3.86kb

 – ├──17｜DIContainer（5）：API接口该怎么设计？.mp3 1.58M

 – ├──17｜DIContainer（5）：API接口该怎么设计？.pdf 2.08M

 – ├──18｜DIContainer（6）：如何实现循环依赖的检查？.md 5.13kb

 – ├──18｜DIContainer（6）：如何实现循环依赖的检查？.mp3 1.91M

 – ├──18｜DIContainer（6）：如何实现循环依赖的检查？.pdf 2.44M

 – ├──19｜DIContainer（7）：如何实现FieldInjection部分的功能？.md 6.52kb

 – ├──19｜DIContainer（7）：如何实现FieldInjection部分的功能？.mp3 1.32M

 – ├──19｜DIContainer（7）：如何实现FieldInjection部分的功能？.pdf 1.88M

 – ├──20｜DIContainer（8）：如何实现MethodInjection部分的功能？.md 7.25kb

 – ├──20｜DIContainer（8）：如何实现MethodInjection部分的功能？.mp3 854.80kb

 – ├──20｜DIContainer（8）：如何实现MethodInjection部分的功能？.pdf 1.92M

 – ├──21｜DIContainer（9）：怎样重构测试代码？.md 22.61kb

 – ├──21｜DIContainer（9）：怎样重构测试代码？.mp3 1.47M

 – ├──21｜DIContainer（9）：怎样重构测试代码？.pdf 2.01M

 – ├──22｜DIContainer（10）：怎样将大粒度的测试重构为等效的小粒度测试代码？.md 8.96kb

 – ├──22｜DIContainer（10）：怎样将大粒度的测试重构为等效的小粒度测试代码？.mp3 1.30M

 – ├──22｜DIContainer（10）：怎样将大粒度的测试重构为等效的小粒度测试代码？.pdf 1.40M

 – ├──23｜DIContainer（11）：如何对ContainerTest进行文档化改造？.md 16.12kb

 – ├──23｜DIContainer（11）：如何对ContainerTest进行文档化改造？.mp3 1.12M

 – ├──23｜DIContainer（11）：如何对ContainerTest进行文档化改造？.pdf 1.18M

 – ├──24｜DIContainer（12）：如何增补功能？.md 9.13kb

 – ├──24｜DIContainer（12）：如何增补功能？.mp3 1.43M

 – ├──24｜DIContainer（12）：如何增补功能？.pdf 1.20M

 – ├──25｜DIContainer（13）：任务上的遗漏该怎么处理？.md 9.92kb

 – ├──25｜DIContainer（13）：任务上的遗漏该怎么处理？.mp3 971.41kb

 – ├──25｜DIContainer（13）：任务上的遗漏该怎么处理？.pdf 1.27M

 – ├──26｜DIContainer（14）：如何重构对Type类型判断的逻辑？.md 11.83kb

 – ├──26｜DIContainer（14）：如何重构对Type类型判断的逻辑？.mp3 1.35M

 – ├──26｜DIContainer（14）：如何重构对Type类型判断的逻辑？.pdf 2.51M

 – ├──27｜DIContainer（15）：如何封装类型判断逻辑？.md 11.49kb

 – ├──27｜DIContainer（15）：如何封装类型判断逻辑？.mp3 1.12M

 – ├──27｜DIContainer（15）：如何封装类型判断逻辑？.pdf 1.96M

 – ├──28｜DIContainer（16）：行为封装会对测试产生什么影响？.md 11.72kb

 – ├──28｜DIContainer（16）：行为封装会对测试产生什么影响？.mp3 990.06kb

 – ├──28｜DIContainer（16）：行为封装会对测试产生什么影响？.pdf 2.47M

 – ├──29｜DIContainer（17）：如何重构ContextConfig内部的实现？.md 14.31kb

 – ├──29｜DIContainer（17）：如何重构ContextConfig内部的实现？.mp3 1.33M

 – ├──29｜DIContainer（17）：如何重构ContextConfig内部的实现？.pdf 1.85M

 – ├──30｜DIContainer（18）：如何增补依赖缺失和循环依赖的测试？.md 14.61kb

 – ├──30｜DIContainer（18）：如何增补依赖缺失和循环依赖的测试？.mp3 1.63M

 – ├──30｜DIContainer（18）：如何增补依赖缺失和循环依赖的测试？.pdf 1.95M

 – ├──31｜DIContainer（19）：Qualifier部分的功能要如何完成？.md 15.17kb

 – ├──31｜DIContainer（19）：Qualifier部分的功能要如何完成？.mp3 1.30M

 – ├──31｜DIContainer（19）：Qualifier部分的功能要如何完成？.pdf 2.27M

 – ├──32｜DIContainer（20）：如何对代码和测试进行重构？.md 15.95kb

 – ├──32｜DIContainer（20）：如何对代码和测试进行重构？.mp3 2.06M

 – ├──32｜DIContainer（20）：如何对代码和测试进行重构？.pdf 2.27M

 – ├──33｜DIContainer（21）：如何处理Singleton生命周期部分的功能？.md 16.21kb

 – ├──33｜DIContainer（21）：如何处理Singleton生命周期部分的功能？.mp3 1.35M

 – ├──33｜DIContainer（21）：如何处理Singleton生命周期部分的功能？.pdf 2.06M

 – ├──34｜DIContainer（22）：如何对Bind的逻辑进行重构？.md 18.64kb

 – ├──34｜DIContainer（22）：如何对Bind的逻辑进行重构？.mp3 1.26M

 – ├──34｜DIContainer（22）：如何对Bind的逻辑进行重构？.pdf 1.80M

 – ├──35｜DIContainer（23）：项目回顾与总结.md 30.30kb

 – ├──35｜DIContainer（23）：项目回顾与总结.mp3 4.27M

 – ├──35｜DIContainer（23）：项目回顾与总结.pdf 3.71M

 – ├──36｜实战中的TDD：RESTfulWebServices.md 4.10kb

 – ├──36｜实战中的TDD：RESTfulWebServices.mp3 1.67M

 – ├──36｜实战中的TDD：RESTfulWebServices.pdf 1.07M

 – ├──37｜RESTfulWebServices（1）：明确架构愿景与架构组件间的交互.md 5.10kb

 – ├──37｜RESTfulWebServices（1）：明确架构愿景与架构组件间的交互.mp3 5.26M

 – ├──37｜RESTfulWebServices（1）：明确架构愿景与架构组件间的交互.pdf 3.16M

 – ├──38｜RESTfulWebServices（2）：根据Spike的结果，要如何调整架构愿景？.md 2.44kb

 – ├──38｜RESTfulWebServices（2）：根据Spike的结果，要如何调整架构愿景？.mp3 1.51M

 – ├──38｜RESTfulWebServices（2）：根据Spike的结果，要如何调整架构愿景？.pdf 1.05M

 – ├──39｜RESTfulWebServices（3）：明确架构愿景与调用栈顺序.md 3.07kb

 – ├──39｜RESTfulWebServices（3）：明确架构愿景与调用栈顺序.mp3 1.59M

 – ├──39｜RESTfulWebServices（3）：明确架构愿景与调用栈顺序.pdf 2.01M

 – ├──40｜RESTfulWebServices（4）：在当前架构愿景下，要如何分解任务？.md 7.30kb

 – ├──40｜RESTfulWebServices（4）：在当前架构愿景下，要如何分解任务？.mp3 4.29M

 – ├──40｜RESTfulWebServices（4）：在当前架构愿景下，要如何分解任务？.pdf 3.35M

 – ├──41｜RESTfulWebServices（5）：如何通过对数据测试的管理来凸显意图？.md 3.25kb

 – ├──41｜RESTfulWebServices（5）：如何通过对数据测试的管理来凸显意图？.mp3 1.51M

 – ├──41｜RESTfulWebServices（5）：如何通过对数据测试的管理来凸显意图？.pdf 2.41M

 – ├──42｜RESTfulWebServices（6）：如何处理JAX-RS定义的异常类？.md 3.69kb

 – ├──42｜RESTfulWebServices（6）：如何处理JAX-RS定义的异常类？.mp3 1.16M

 – ├──42｜RESTfulWebServices（6）：如何处理JAX-RS定义的异常类？.pdf 1.87M

 – ├──43｜RESTfulWebServices（7）：剩下两个SadPath场景该如何处理？.md 4.11kb

 – ├──43｜RESTfulWebServices（7）：剩下两个SadPath场景该如何处理？.mp3 982.00kb

 – ├──43｜RESTfulWebServices（7）：剩下两个SadPath场景该如何处理？.pdf 1.93M

 – ├──44｜RESTfulWebServices（8）：如何在现有代码的基础上构造测试？.md 5.04kb

 – ├──44｜RESTfulWebServices（8）：如何在现有代码的基础上构造测试？.mp3 1.42M

 – ├──44｜RESTfulWebServices（8）：如何在现有代码的基础上构造测试？.pdf 2.07M

 – ├──45｜RESTfulWebServices（9）：通过伦敦学派得到的测试风格是什么样的？.md 18.19kb

 – ├──45｜RESTfulWebServices（9）：通过伦敦学派得到的测试风格是什么样的？.mp3 1.41M

 – ├──45｜RESTfulWebServices（9）：通过伦敦学派得到的测试风格是什么样的？.pdf 2.27M

 – ├──46｜RESTfulWebServices（10）：伦敦学派与经典学派的测试节奏有何不同？.md 8.82kb

 – ├──46｜RESTfulWebServices（10）：伦敦学派与经典学派的测试节奏有何不同？.mp3 2.17M

 – ├──46｜RESTfulWebServices（10）：伦敦学派与经典学派的测试节奏有何不同？.pdf 2.64M

 – ├──47｜RESTfulWebServices（11）：如何通过Spike来验证架构愿景？.md 2.26kb

 – ├──47｜RESTfulWebServices（11）：如何通过Spike来验证架构愿景？.mp3 1.53M

 – ├──47｜RESTfulWebServices（11）：如何通过Spike来验证架构愿景？.pdf 949.88kb

 – ├──48｜RESTfulWebServices（12）：如何调整接口和架构愿景？.md 1.72kb

 – ├──48｜RESTfulWebServices（12）：如何调整接口和架构愿景？.mp3 1.42M

 – ├──48｜RESTfulWebServices（12）：如何调整接口和架构愿景？.pdf 1.26M

 – ├──49｜RESTfulWebService（13）：如何SpikeSub-ResourceLocator？.md 1.69kb

 – ├──49｜RESTfulWebService（13）：如何SpikeSub-ResourceLocator？.mp3 1.81M

 – ├──49｜RESTfulWebService（13）：如何SpikeSub-ResourceLocator？.pdf 1.26M

 – ├──50｜RESTfulWebServices（14）：分解任务与Setup测试.md 2.85kb

 – ├──50｜RESTfulWebServices（14）：分解任务与Setup测试.mp3 1.26M

 – ├──50｜RESTfulWebServices（14）：分解任务与Setup测试.pdf 1.28M

 – ├──51｜RESTfulWebServices（15）：为什么选择在第一个测试之后就开始重构？.md 2.28kb

 – ├──51｜RESTfulWebServices（15）：为什么选择在第一个测试之后就开始重构？.mp3 1.33M

 – ├──51｜RESTfulWebServices（15）：为什么选择在第一个测试之后就开始重构？.pdf 1.72M

 – ├──52｜RESTfulWebServices（16）：重构手法之设计方法名的名称.md 2.44kb

 – ├──52｜RESTfulWebServices（16）：重构手法之设计方法名的名称.mp3 1.41M

 – ├──52｜RESTfulWebServices（16）：重构手法之设计方法名的名称.pdf 2.16M

 – ├──53｜RESTfulWebServices（17）：如何进行Spike的架构愿景细化？.md 2.42kb

 – ├──53｜RESTfulWebServices（17）：如何进行Spike的架构愿景细化？.mp3 1.06M

 – ├──53｜RESTfulWebServices（17）：如何进行Spike的架构愿景细化？.pdf 1.87M

 – ├──54｜RESTfulWebServices（18）：如何实现UriTemplate的主要功能？.md 2.62kb

 – ├──54｜RESTfulWebServices（18）：如何实现UriTemplate的主要功能？.mp3 1.34M

 – ├──54｜RESTfulWebServices（18）：如何实现UriTemplate的主要功能？.pdf 1.78M

 – ├──55｜RESTfulWebServices（19）：如何更有效地构造测试数据？.md 3.95kb

 – ├──55｜RESTfulWebServices（19）：如何更有效地构造测试数据？.mp3 1.17M

 – ├──55｜RESTfulWebServices（19）：如何更有效地构造测试数据？.pdf 1.72M

 – ├──56｜RESTfulWebServices（20）：为什么要通过测试的方法来驱动出代码结构？.md 2.12kb

 – ├──56｜RESTfulWebServices（20）：为什么要通过测试的方法来驱动出代码结构？.mp3 1.43M

 – ├──56｜RESTfulWebServices（20）：为什么要通过测试的方法来驱动出代码结构？.pdf 1.59M

 – ├──57｜RESTfulWebServices（21）：按照三角法，该如何增加新的测试案例？.md 3.18kb

 – ├──57｜RESTfulWebServices（21）：按照三角法，该如何增加新的测试案例？.mp3 1.48M

 – ├──57｜RESTfulWebServices（21）：按照三角法，该如何增加新的测试案例？.pdf 1.61M

 – ├──58｜RESTfulWebServices（22）：重构还是继续完成功能？.md 4.09kb

 – ├──58｜RESTfulWebServices（22）：重构还是继续完成功能？.mp3 1.74M

 – ├──58｜RESTfulWebServices（22）：重构还是继续完成功能？.pdf 2.25M

 – ├──59｜RESTfulWebServices（23）：如何构造测试数据？.md 4.34kb

 – ├──59｜RESTfulWebServices（23）：如何构造测试数据？.mp3 1.16M

 – ├──59｜RESTfulWebServices（23）：如何构造测试数据？.pdf 1.72M

 – ├──60｜RESTfulWebServices（24）：RootResource的测试要如何改造？.md 5.40kb

 – ├──60｜RESTfulWebServices（24）：RootResource的测试要如何改造？.mp3 1.15M

 – ├──60｜RESTfulWebServices（24）：RootResource的测试要如何改造？.pdf 1023.15kb

 – ├──61｜RESTfulWebServices（25）：如何重构DefaultResourceRouter中的Result结构？.md 9.84kb

 – ├──61｜RESTfulWebServices（25）：如何重构DefaultResourceRouter中的Result结构？.mp3 1.19M

 – ├──61｜RESTfulWebServices（25）：如何重构DefaultResourceRouter中的Result结构？.pdf 2.06M

 – ├──62｜RESTfulWebServices（26）：如何继续划分ResourceLocator的任务？.md 8.27kb

 – ├──62｜RESTfulWebServices（26）：如何继续划分ResourceLocator的任务？.mp3 1.74M

 – ├──62｜RESTfulWebServices（26）：如何继续划分ResourceLocator的任务？.pdf 2.49M

 – ├──63｜RESTfulWebServices（27）：如何通过重构修改接口？.md 8.88kb

 – ├──63｜RESTfulWebServices（27）：如何通过重构修改接口？.mp3 1.70M

 – ├──63｜RESTfulWebServices（27）：如何通过重构修改接口？.pdf 2.41M

 – ├──64｜RESTfulWebServices（28）：如何重构Resource、SubResource等接口与实现？.md 10.01kb

 – ├──64｜RESTfulWebServices（28）：如何重构Resource、SubResource等接口与实现？.mp3 1.25M

 – ├──64｜RESTfulWebServices（28）：如何重构Resource、SubResource等接口与实现？.pdf 1.56M

 – ├──65｜RESTfulWebServices（29）：后续任务将要如何划分与实现？.md 9.46kb

 – ├──65｜RESTfulWebServices（29）：后续任务将要如何划分与实现？.mp3 3.95M

 – ├──65｜RESTfulWebServices（29）：后续任务将要如何划分与实现？.pdf 2.01M

 – ├──66｜RESTfulWebServices（30）：什么情况下应该使用行为验证？.md 9.07kb

 – ├──66｜RESTfulWebServices（30）：什么情况下应该使用行为验证？.mp3 3.92M

 – ├──66｜RESTfulWebServices（30）：什么情况下应该使用行为验证？.pdf 2.13M

 – ├──67｜RESTfulWebServices（31）：对于option的测试策略应该是怎样的？.md 9.68kb

 – ├──67｜RESTfulWebServices（31）：对于option的测试策略应该是怎样的？.mp3 1.55M

 – ├──67｜RESTfulWebServices（31）：对于option的测试策略应该是怎样的？.pdf 1.89M

 – ├──68｜RESTfulWebServices（32）：目前代码中的一个重大Bug是什么？.md 10.95kb

 – ├──68｜RESTfulWebServices（32）：目前代码中的一个重大Bug是什么？.mp3 1.27M

 – ├──68｜RESTfulWebServices（32）：目前代码中的一个重大Bug是什么？.pdf 1.61M

 – ├──69｜RESTfulWebServices（33）：如何拆分对于injection部分的需求？.md 11.40kb

 – ├──69｜RESTfulWebServices（33）：如何拆分对于injection部分的需求？.mp3 1.45M

 – ├──69｜RESTfulWebServices（33）：如何拆分对于injection部分的需求？.pdf 1.90M

 – ├──70｜RESTfulWebServices（34）：在当前代码结构下，要如何进行重构？.md 12.37kb

 – ├──70｜RESTfulWebServices（34）：在当前代码结构下，要如何进行重构？.mp3 1.69M

 – ├──70｜RESTfulWebServices（34）：在当前代码结构下，要如何进行重构？.pdf 2.26M

 – ├──71｜RESTfulWebServices（35）：如何将测试改为动态测试？.md 13.14kb

 – ├──71｜RESTfulWebServices（35）：如何将测试改为动态测试？.mp3 1.48M

 – ├──71｜RESTfulWebServices（35）：如何将测试改为动态测试？.pdf 2.33M

 – ├──72｜RESTfulWebServices（36）：在现有结构下，如何支持转换构造函数？.md 13.37kb

 – ├──72｜RESTfulWebServices（36）：在现有结构下，如何支持转换构造函数？.mp3 914.40kb

 – ├──72｜RESTfulWebServices（36）：在现有结构下，如何支持转换构造函数？.pdf 1.95M

 – ├──73｜RESTfulWebServices（37）：再增加converter方法时，步骤有什么不同？.md 14.41kb

 – ├──73｜RESTfulWebServices（37）：再增加converter方法时，步骤有什么不同？.mp3 1.12M

 – ├──73｜RESTfulWebServices（37）：再增加converter方法时，步骤有什么不同？.pdf 2.30M

 – ├──74｜RESTfulWebServices（38）：如何提取方法调用部分？.md 15.29kb

 – ├──74｜RESTfulWebServices（38）：如何提取方法调用部分？.mp3 1.05M

 – ├──74｜RESTfulWebServices（38）：如何提取方法调用部分？.pdf 2.60M

 – ├──75｜RESTfulWebServices（39）：如何使用继承的方式来复用测试？.md 11.18kb

 – ├──75｜RESTfulWebServices（39）：如何使用继承的方式来复用测试？.mp3 1.34M

 – ├──75｜RESTfulWebServices（39）：如何使用继承的方式来复用测试？.pdf 2.22M

 – ├──76｜RESTfulWebServices（40）：如何开展有效的集成测试？.md 11.10kb

 – ├──76｜RESTfulWebServices（40）：如何开展有效的集成测试？.mp3 1.54M

 – ├──76｜RESTfulWebServices（40）：如何开展有效的集成测试？.pdf 1.95M

 – ├──77｜RESTfulWebServices（41）：对于资源的访问，我们需要补充哪些相关功能？.md 11.17kb

 – ├──77｜RESTfulWebServices（41）：对于资源的访问，我们需要补充哪些相关功能？.mp3 979.56kb

 – ├──77｜RESTfulWebServices（41）：对于资源的访问，我们需要补充哪些相关功能？.pdf 1.63M

 – ├──78｜RESTfulWebServices（42）：项目总结与回顾.md 11.37kb

 – ├──78｜RESTfulWebServices（42）：项目总结与回顾.mp3 2.40M

 – ├──78｜RESTfulWebServices（42）：项目总结与回顾.pdf 2.20M

 – ├──79｜线段编辑器：架构思路与任务拆分.md 2.18kb

 – ├──79｜线段编辑器：架构思路与任务拆分.mp3 2.39M

 – ├──79｜线段编辑器：架构思路与任务拆分.pdf 1.66M

 – ├──80｜LineEditor（2）：如何重构生成与更新锚点控制点的逻辑？.md 2.28kb

 – ├──80｜LineEditor（2）：如何重构生成与更新锚点控制点的逻辑？.mp3 1.16M

 – ├──80｜LineEditor（2）：如何重构生成与更新锚点控制点的逻辑？.pdf 1023.24kb

 – ├──81｜结束语：掌握TDD的那天，我才成为了可靠高效的职业程序员.md 5.45kb

 – ├──81｜结束语：掌握TDD的那天，我才成为了可靠高效的职业程序员.mp3 2.29M

 – ├──81｜结束语：掌握TDD的那天，我才成为了可靠高效的职业程序员.pdf 1.01M

 – ├──代码评点01｜不同语言TDD的节奏有何不同？.md 1.79kb

 – ├──代码评点01｜不同语言TDD的节奏有何不同？.mp3 1.75M

 – ├──代码评点01｜不同语言TDD的节奏有何不同？.pdf 2.62M

 – ├──代码评点02｜什么是合适TDD的语言和IDE？.md 1.51kb

 – ├──代码评点02｜什么是合适TDD的语言和IDE？.mp3 2.00M

 – ├──代码评点02｜什么是合适TDD的语言和IDE？.pdf 1.32M

 – ├──开篇词｜为什么TDD是当前最具工程效能的研发流程？.md 12.61kb

 – ├──开篇词｜为什么TDD是当前最具工程效能的研发流程？.mp3 10.98M

 – ├──开篇词｜为什么TDD是当前最具工程效能的研发流程？.pdf 6.52M

 – ├──课前必读01｜20年前的“老古董”技术，为什么还值得开个课？.md 8.41kb

 – ├──课前必读01｜20年前的“老古董”技术，为什么还值得开个课？.mp3 9.13M

 – ├──课前必读01｜20年前的“老古董”技术，为什么还值得开个课？.pdf 2.20M

 – ├──课前必读02｜程序员究竟是搞技术的，还是做工程的？.md 19.24kb

 – ├──课前必读02｜程序员究竟是搞技术的，还是做工程的？.mp3 18.34M

 – ├──课前必读02｜程序员究竟是搞技术的，还是做工程的？.pdf 1.50M

 – ├──期末测试｜赴一场100分之约！.md 0.78kb

 – ├──期末测试｜赴一场100分之约！.mp3 798.77kb

 – ├──期末测试｜赴一场100分之约！.pdf 689.86kb

 – ├──用户故事01｜aoe：如果把《重构》这本书拍成电视剧.md 11.53kb

 – ├──用户故事01｜aoe：如果把《重构》这本书拍成电视剧.mp3 9.96M

 – └──用户故事01｜aoe：如果把《重构》这本书拍成电视剧.pdf 4.38M

  