# Go并发编程实战课

## 联系方式

客服微信号：itziyuan_xiaozhi

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/common/20240614073449/666b82192834a.jpg" width="200" height="200" alt="二维码">

## 课程简介

下载链接：https://it.bcwex.shop/posts?id=2163

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/yun/20240515183708/6644905419e60.jpg" width="500" alt="">

   一个丰富完整的并发原语知识库 彻底搞懂并发原语的实现原理及使用技巧 20+ 大型项目的真实踩坑案例及解决方案 分布式场景中并发问题的应对策略     课程模块设计 课程分为 5 大模块。

  基本并发原语：从标准库中的基本并发原语入手，详细介绍互斥锁 Mutex、RWMutex、Waitgroup、Cond、Pool、Context 等的实现机制和使用技巧，带你搞定并发编程中的常用类型。 原子操作：具体介绍标准库中的原子操作，这是其它并发原语的基础。学会了这部分内容，就可以自己创造新的并发原语。 Channel：Channel 类型是 Go 语言独特的类型，不仅会介绍它的基本用法，而且还会详解它的处理场景和应用模式，帮你规避陷阱。 扩展并发原语：目前来看，Go 开发组不准备在标准库中扩充并发原语了，但是还有一些并发原语应用得非常广泛。课程会重点讲解信号量、SingleFlight、循环栅栏、ErrGroup 等，让你能在处理一些并发问题时事半功倍。 分布式并发原语：分布式并发原语是应对大规模的应用程序中并发问题的并发类型，主要会介绍使用 etcd 实现的一些分布式并发原语，比如 Leader 选举、分布式互斥锁、分布式读写锁、分布式队列等，带你攻克分布式场景中的并发难题。  

 

 

 

  〖课程截图〗:

  

 ├──jk61801-Go并发编程实战课(PDF+MP3+HTML完结)

 | ├──00-开篇词 (1讲)

 | | ├──00 l 开篇词丨想吃透Go并发编程，你得这样学！.html 4.74M

 | | ├──00 l 开篇词丨想吃透Go并发编程，你得这样学！.m4a 8.83M

 | | └──00 l 开篇词丨想吃透Go并发编程，你得这样学！.pdf 4.44M

 | ├──01-基本并发原语 (11讲)

 | | ├──01丨Mutex：如何解决资源并发访问问题？.html 7.32M

 | | ├──01丨Mutex：如何解决资源并发访问问题？.m4a 11.86M

 | | ├──01丨Mutex：如何解决资源并发访问问题？.pdf 4.58M

 | | ├──02丨Mutex：庖丁解牛看实现.html 6.14M

 | | ├──02丨Mutex：庖丁解牛看实现.m4a 20.65M

 | | ├──02丨Mutex：庖丁解牛看实现.pdf 4.48M

 | | ├──03｜Mutex：4种易错场景大盘点.html 6.00M

 | | ├──03｜Mutex：4种易错场景大盘点.m4a 18.65M

 | | ├──03｜Mutex：4种易错场景大盘点.pdf 3.29M

 | | ├──04｜Mutex：骇客编程，如何拓展额外功能？.html 6.24M

 | | ├──04｜Mutex：骇客编程，如何拓展额外功能？.m4a 8.13M

 | | ├──04｜Mutex：骇客编程，如何拓展额外功能？.pdf 3.81M

 | | ├──05｜RWMutex：读写锁的实现原理及避坑指南.html 3.86M

 | | ├──05｜RWMutex：读写锁的实现原理及避坑指南.m4a 19.22M

 | | ├──05｜RWMutex：读写锁的实现原理及避坑指南.pdf 2.64M

 | | ├──06丨WaitGroup：协同等待，任务编排利器.html 4.94M

 | | ├──06丨WaitGroup：协同等待，任务编排利器.m4a 14.07M

 | | ├──06丨WaitGroup：协同等待，任务编排利器.pdf 3.01M

 | | ├──07丨Cond：条件变量的实现机制及避坑指南.html 4.34M

 | | ├──07丨Cond：条件变量的实现机制及避坑指南.m4a 11.85M

 | | ├──07丨Cond：条件变量的实现机制及避坑指南.pdf 2.56M

 | | ├──08丨Once：一个简约而不简单的并发原语.html 2.69M

 | | ├──08丨Once：一个简约而不简单的并发原语.m4a 11.09M

 | | ├──08丨Once：一个简约而不简单的并发原语.pdf 1.57M

 | | ├──09丨 map：如何实现线程安全的map类型？.html 3.47M

 | | ├──09丨 map：如何实现线程安全的map类型？.m4a 15.29M

 | | ├──09丨 map：如何实现线程安全的map类型？.pdf 2.24M

 | | ├──10丨 Pool：性能提升大杀器.html 5.11M

 | | ├──10丨 Pool：性能提升大杀器.m4a 20.71M

 | | ├──10丨 Pool：性能提升大杀器.pdf 3.20M

 | | ├──11丨 Context：信息穿透上下文.html 3.61M

 | | ├──11丨 Context：信息穿透上下文.m4a 13.80M

 | | └──11丨 Context：信息穿透上下文.pdf 2.39M

 | ├──02-原子操作 (1讲)

 | | ├──12丨 atomic：要保证原子操作，一定要使用这几种方法.html 4.13M

 | | ├──12丨 atomic：要保证原子操作，一定要使用这几种方法.m4a 14.77M

 | | └──12丨 atomic：要保证原子操作，一定要使用这几种方法.pdf 2.34M

 | ├──03-Channel (3讲)

 | | ├──13丨 Channel：另辟蹊径，解决并发问题.html 5.41M

 | | ├──13丨 Channel：另辟蹊径，解决并发问题.m4a 18.10M

 | | ├──13丨 Channel：另辟蹊径，解决并发问题.pdf 3.53M

 | | ├──14丨 Channel：透过代码看典型的应用模式.html 3.58M

 | | ├──14丨 Channel：透过代码看典型的应用模式.m4a 14.68M

 | | ├──14丨 Channel：透过代码看典型的应用模式.pdf 2.23M

 | | ├──15丨 内存模型：Go如何保证并发读写的顺序？.html 3.93M

 | | ├──15丨 内存模型：Go如何保证并发读写的顺序？.m4a 16.51M

 | | └──15丨 内存模型：Go如何保证并发读写的顺序？.pdf 2.53M

 | ├──04-扩展并发原语 (3讲)

 | | ├──16 _ Semaphore：一篇文章搞懂信号量.html 2.85M

 | | ├──16 _ Semaphore：一篇文章搞懂信号量.pdf 1.86M

 | | ├──16丨Semaphore：一篇文章搞懂信号量.m4a 11.67M

 | | ├──17 _ SingleFlight 和 CyclicBarrier：请求合并和循环栅栏该怎么用？.html 3.31M

 | | ├──17 _ SingleFlight 和 CyclicBarrier：请求合并和循环栅栏该怎么用？.pdf 2.06M

 | | ├──17丨SingleFlight和CyclicBarrier：请求合并和循环栅栏该怎么用？.m4a 11.72M

 | | ├──18 _ 分组操作：处理一组子任务，该用什么并发原语？.html 3.31M

 | | ├──18 _ 分组操作：处理一组子任务，该用什么并发原语？.pdf 1.94M

 | | └──18丨分组操作：处理一组子任务，该用什么并发原语？.m4a 16.31M

 | ├──05-分布式并发原语 (2讲)

 | | ├──19 _ 在分布式环境中，Leader选举、互斥锁和读写锁该如何实现？.html 3.24M

 | | ├──19 _ 在分布式环境中，Leader选举、互斥锁和读写锁该如何实现？.pdf 1.83M

 | | ├──19丨在分布式环境中，Leader选举、互斥锁和读写锁该如何实现？.m4a 8.72M

 | | ├──20 _ 在分布式环境中，队列、栅栏和STM该如何实现？.html 2.73M

 | | ├──20 _ 在分布式环境中，队列、栅栏和STM该如何实现？.pdf 1.53M

 | | └──20丨在分布式环境中，队列、栅栏和STM该如何实现？.m4a 10.07M

 | └──06-结束语 (1讲)

 | | ├──结束语 _ 再聊Go并发编程的价值和精进之路.html 3.45M

 | | ├──结束语 _ 再聊Go并发编程的价值和精进之路.pdf 2.32M

 | | └──结束语丨再聊Go并发编程的价值和精进之路.m4a 7.22M

  