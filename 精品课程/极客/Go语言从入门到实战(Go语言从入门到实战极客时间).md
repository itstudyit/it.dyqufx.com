# Go语言从入门到实战(Go语言从入门到实战极客时间)

## 联系方式

客服微信号：itziyuan_xiaozhi

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/common/20240614073449/666b82192834a.jpg" width="200" height="200" alt="二维码">

## 课程简介

下载链接：https://it.bcwex.shop/posts?id=2305

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/yun/20240515183813/6644909564ab4.jpg" width="500" alt="">

  ├──-Go语言从入门到实战

 精品it资源网



 | ├──01丨Go语言课程介绍_.mp4 112.45M

 | ├──02丨内容综述_.mp4 40.85M

 | ├──03丨Go 语言简介：历史背景、发展现状及语言特性_.mp4 17.89M

 | ├──04丨编写第一个Go程序_.mp4 41.05M

 | ├──05丨变量、常量以及与其他语言的差异_.mp4 68.46M

 | ├──06丨数据类型_.mp4 45.00M

 | ├──07丨运算符_.mp4 44.81M

 | ├──08丨条件和循环_.mp4 50.37M

 | ├──09丨数组和切片_.mp4 95.18M

 | ├──10丨Map 声明、元素访问及遍历_.mp4 43.49M

 | ├──11丨Map与工厂模式，在Go语言中实现Set_.mp4 38.56M

 | ├──12丨字符串_.mp4 68.34M

 | ├──13丨Go 语言的函数_.mp4 38.63M

 | ├──14丨可变参数和 defer_.mp4 24.43M

 | ├──15丨行为的定义和实现_.mp4 42.80M

 | ├──16丨Go语言的相关接口_.mp4 57.11M

 | ├──17丨扩展与复用_.mp4 58.08M

 | ├──18丨不一样的接口类型，一样的多态_.mp4 56.54M

 | ├──19丨编写好的错误处理_.mp4 85.83M

 | ├──20丨panic和recover_.mp4 26.49M

 | ├──21丨构建可复用的模块（包）_.mp4 65.89M

 | ├──22丨依赖管理_.mp4 28.03M

 | ├──23丨协程机制_.mp4 30.17M

 | ├──24丨共享内存并发机制_.mp4 46.77M

 | ├──25丨CSP并发机制_.mp4 52.32M

 | ├──26丨多路选择和超时_.mp4 24.10M

 | ├──27丨channel的关闭和广播_.mp4 32.29M

 | ├──28丨任务的取消_.mp4 12.30M

 | ├──29丨Context与任务取消_.mp4 15.68M

 | ├──30丨只运行一次_.mp4 39.55M

 | ├──31丨仅需任意任务完成_.mp4 29.99M

 | ├──32丨所有任务完成_.mp4 31.00M

 | ├──33丨对象池_.mp4 43.81M

 | ├──34丨sync_.mp4 39.51M

 | ├──35丨单元测试_.mp4 47.07M

 | ├──36丨Benchmark_.mp4 35.18M

 | ├──37丨BDD_.mp4 27.31M

 | ├──38丨反射编程_.mp4 33.12M

 | ├──39丨万能程序_.mp4 56.56M

 | ├──40丨不安全编程_.mp4 39.60M

 | ├──41丨实现pipe-filter framework_.mp4 41.66M

 | ├──42丨实现micro-kernel framework_.mp4 56.26M

 | ├──43丨内置JSON解析_.mp4 24.21M

 | ├──44丨easyjson_.mp4 32.10M

 | ├──45丨HTTP服务_.mp4 29.96M

 | ├──46丨构建Restful服务_.mp4 46.36M

 | ├──47丨性能分析工具_.mp4 68.56M

 | ├──48丨性能调优示例_.mp4 71.19M

 | ├──49丨别让性能被锁住_.mp4 67.29M

 | ├──50丨GC友好的代码_.mp4 61.62M

 | ├──51丨高效字符串连接_.mp4 26.78M

 | ├──52丨面向错误的设计_.mp4 36.48M

 | ├──53丨面向恢复的设计_.mp4 22.39M

 | ├──54丨Chaos Engineering_.mp4 31.75M

 | └──55丨结束语_.mp4 22.02M

 Golang入门到项目实战 | golang方法 go语言没有面向对象的特性，也没有类对象的概念。但是，可以使用结构体来模拟这些特性，我们都知道面向对象里面有类方法等概念。我们也可以声明一些方法，属于某个结构体。Go中的方法，是一种特殊的函数，定义域struct之上（与struct关联、绑定），被称为struct的接受者（receiver）。通俗的讲，方法就是有接收者的函数。语法格式如下：mytype：定义一个结构体recv：接受该方法的结构体（receiver）my_method：方法名称para：参数列表return_type：返回值类型从语法格式可以看出，一个方法和一个函数非常相似，多了一个接受类型。

 Golang入门到项目实战 | golang并发变成之通道channel Go提供了一种称为通道的机制，用于在goroutine之间共享数据。当您作为goroutine执行并发活动时，需要在goroutine之间共享资源或数据，通道充当goroutine之间的管道（管道）并提供一种机制来保证同步交换。根据数据交换的行为，有两种类型的通道：无缓冲通道和缓冲通道。无缓冲通道用于执行goroutine之间的同步通信，而缓冲通道用于执行异步通信。无缓冲通道保证在发送和接收发生的瞬间两个goroutine之间的交换。缓冲通道没有这样的保证。通道由make函数创建，该函数指定chan关键字和通道的元素类型。这是创建无缓冲和缓冲通道的代码块：使用内置函数make创建无缓冲和缓冲通道。make的第一个参数需要关键字chan，然后是通道允许交换的数据类型。这是将值发送到通道的代码块需要使用&lt;-运算符：一个包含5个值的缓冲区的字符串类型的goroutine1通道。然后我们通过通道发送字符串“Australia”。这是从通道接收值的代码块：&lt;- 运算符附加到通道变量（goroutine1）的左侧，以接收来自通道的值。在无缓冲通道中，在接收到任何值之前没有能力保存它。在这种类型的通道中，发送和接收goroutine在任何发送或接收操作完成之前的同一时刻都准备就绪。如果两个goroutine没有在同一时刻准备好，则通道会让执行其各自发送或接收操作的goroutine首先等待。同步是通道上发送和接收之间交互的基础。没有另一个就不可能发生。在缓冲通道中，有能力在接收到一个或多个值之前保存它们。在这种类型的通道中，不要强制goroutine在同一时刻准备好执行发送和接收。当发送和接收阻塞时也有不同的条件。只有当通道中没有要接收的值时，接收才会阻塞。仅当没有可用缓冲区来放置正在发送的值时，发送才会阻塞。

 go语言做串口通信，我应该从什么地方入手，IO是什么？有什么用？ 期待看到有用的回答！

 GO语言能做些什么？ go 语言被设计成一门应用于搭载 web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，go 语言无疑比大多数其它语言有着更高的开发效率。学习go语言，可以说是很简单的，入门快，想学习go语言，可以到黑马程序员看看，有新出的教程。

  