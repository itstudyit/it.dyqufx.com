# Java程序性能优化：让你的Java程序更快、更稳定

## 联系方式

客服微信号：itziyuan_xiaozhi

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/common/20240614073449/666b82192834a.jpg" width="200" height="200" alt="二维码">

## 课程简介

下载链接：https://it.bcwex.shop/posts?id=3846

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/yun/20240515185354/664494425a3c5.jpg" width="500" alt="">

  课程介绍:

 Java是目前应用为广泛的软件开发平台，学习针对Java程序的优化方法有重要的现实意义。《Java程序性能优化：让你的Java程序更快、更稳定》以Java性能调优为主线，系统地阐述了与Java性能优化相关的知识与技巧。

 《Java程序性能优化：让你的Java程序更快、更稳定》共6章，先后从软件设计、软件编码、JVM调优以及程序故障排斥等方面介绍针对Java程序的优化方法。第1章介绍性能的基本概念、定律、系统调优的过程和注意事项。第2章从设计层面介绍与性能相关的设计模式、组件。第3章从代码层面介绍如何编写高性能的Java程序。第4章介绍了并行开发和如何通过多线程提高系统性能。第5章立足于JVM虚拟机层面，介绍如何通过设置合理的JVM参数提升Java程序的性能。第6章为工具篇，介绍了获取和监控程序或系统性能指标的各种工具，包括相关的故障排查工具。

 《Java程序性能优化：让你的Java程序更快、更稳定》适合所有Java程序员、软件设计师、架构师以及软件开发爱好者，对于有一定经验的Java工程师，本书更能帮助他突破技术瓶颈，深入Java内核开发!

 Java程序性能优化：让你的Java程序更快、更稳定



 3.5.7 展开循环

 2.2.5 负载均衡

 1.4 小结

 1.2.5 操作系统调优

 2.1 善用设计模式

 &nbsp;

 2.3 小结

 3.3.2 Buffer的基本原理

 3.1.2 subString()方法的内存泄漏

 3.2.5 RandomAccess接口

 2.2 常用优化组件和方法

 3.2.2 Map接口

 课程目录

 3.2 核心数据结构

 &nbsp;

 2.2.7 空间换时间

 3.2.4 优化集合访问代码

 1.2.2 代码调优

 3.3.4 MappedByteBuffer性能评估

 3.2.3 Set接口

 &nbsp;

 &nbsp;

 2.2.2 缓存(Cache)

 4.2.4 自定义线程池

 &nbsp;

 &nbsp;

 &nbsp;

 4.5.3 减小锁持有时间

 3.5.8 布尔运算代替位运算

 4.4.7 ThreadLocal线程局部变量

 4.3.4 并发Queue

 4.6.2 原子操作

 &nbsp;

 1.1.1 看懂程序的性能

 1.1.3 木桶原理与性能瓶颈

 1.2.3 JVM调优

 2.2.3 对象复用——“池”

 2.1.3 享元模式

 4.5.5 读写分离锁来替换独占锁

 3.5.2 使用局部变量

 &nbsp;

 3.1.1 String对象及其特点

 2.1.7 业务代理模式

 &nbsp;

 &nbsp;

 4.6.4 Amino集合

 4.6.3 Amino框架介绍

 2.1.4 装饰者模式

 4.5.2 避免死锁

 4.2.6 扩展ThreadPoolExecutor

 4.5.10 锁消除(Lock Elimination)

 2.1.6 Value Object模式

 3.3.1 NIO的Buffer类族和Channel

 4.2.2 简单的线程池实现

 4.3 JDK并发数据结构

 1.2.4 数据库调优

 &nbsp;

 &nbsp;

 3.5.9 使用arrayCopy ()

 4.5 “锁”的性能和优化

 第2章 设计优化

 3.5.5 一维数组代替二维数组

 &nbsp;

 &nbsp;

 4.5.4 减小锁粒度

 3.1.3 字符串分割和查找

 4.6.7 Amino简单调度模式

 3.3 使用NIO提升性能

 4.4.6 Semaphore信号量

 &nbsp;

 4.7.2 Kilim框架简介

 第5章 JVM调优

 4.6.6 Amino图

 第3章 Java程序优化

 4.4.2 同步关键字synchronized

 1.1 性能概述

 3.5.12 静态方法替代实例方法

 4.4.4 ReadWriteLock读写锁

 3.4.2 软引用

 &nbsp;

 &nbsp;

 3.1.4 StringBuffer和StringBuilder

 3.5.3 位运算代替乘除法

 2.1.2 代理模式

 &nbsp;

 4.3.1 并发List

 4.1.2 Master-Worker模式

 3.1 字符串优化处理

 4.5.7 重入锁ReentrantLock和内部锁synchronized

 1.1.2 性能的参考指标

 4.5.6 锁分离

 4.1 并行程序设计模式

 1.1.4 Amdahl定律

 3.5.6 提取表达式

 4.5.11 锁偏向(Biased Lock)

 4.4 并发控制方法

 &nbsp;

 3.5.1 慎用异常

 3.5.4 替换switch

 3.3.5 直接内存访问

 4.1.1 Future模式

 4.6 无锁的并行计算

 4.5.1 线程的开销

 4.1.5 生产者-消费者模式

 4.4.3 ReentrantLock重入锁

 2.1.5 观察者模式

 4.6.1 非阻塞的同步/无锁

 3.4.4 虚引用

 4.5.8 锁粗化(Lock Coarsening)

 2.2.4 并行替代串行

 3.4 引用类型

 2.2.1 缓冲(Buffer)

 4.7.3 Task及其状态

 &nbsp;

 3.4.1 强引用

 4.2.5 优化线程池大小

 1.3.1 优化的一般步骤

 4.4.5 Condition对象

 3.3.3 Buffer的相关操作

 3.4.5 WeakHashMap类及其实现

 4.1.4 不变模式

 4.5.9 自旋锁(Spinning Lock)

 &nbsp;

 &nbsp;

 4.3.2 并发Set

 2.1.1 单例模式

 2.2.6 时间换空间

 3.5 有助于改善性能的技巧

 4.7 协程

 3.4.3 弱引用

 4.7.5 Kilim开发环境配置

 4.2.1 无限制线程的缺陷

 1.3 基本调优策略和手段

 4.7.7 多任务通信

 4.8 小结

 1.2.1 设计调优

 第1章 Java性能调优概述

 3.2.1 List接口

 1.3.2 系统优化注意事项

 4.6.5 Amino树

 1.2 性能调优的层次

 第4章 并行程序开发及优化

 3.6 小结

 4.4.1 Java内存模型与volatile

 4.7.4 Fiber及其状态

 3.5.11 使用clone()代替new

 4.3.5 并发Deque

 3.5.10 使用Buffer进行I/O操作

 4.7.8 Kilim实例及性能评估

 4.7.1 协程的概念

 4.1.3 Guarded Suspension模式

 4.2.3 Executor框架

 4.7.6 Kilim之Hello World

 5.3.1 垃圾收集的作用

 4.2 JDK多任务执行框架

 5.5.6 控制GC

 6.2.4 pslist命令行

 6.4.2 Java程序概况

 4.3.3 并发Map

 6.5.7 MBean管理

 &nbsp;

 6.6.5 程序化OQL

 5.2.1 设置最大堆内存

 5.2.4 设置持久代

 5.1 Java虚拟机内存模型

 5.3.14 GC相关参数总结

 6.6.1 Visual VM的OQL基本语法

 6.7.1 初识MAT

 6.5.1 Visual VM连接应用程序

 6.8.2 From子句

 6.7.4 垃圾回收根

 6.7 MAT内存分析工具

 5.3.6 老年代串行收集器

 6.7.2 浅堆和深堆

 6.5.2 监控应用程序概况

 5.2 JVM内存分配参数

 5.3.8 新生代并行回收(Parallel Scavenge)收集器

 5.2.3 设置新生代

 &nbsp;

 6.8.3 Where子句

 5.3.9 老年代并行回收收集器

 6.3.1 jps命令

 &nbsp;

 6.9.7 触发器

 &nbsp;

 &nbsp;

 &nbsp;

 &nbsp;

 &nbsp;

 &nbsp;

 &nbsp;

 6.7.9 集合使用情况分析

 5.3.7 并行收集器

 6.7.8 线程分析

 6.3.6 jstack命令

 6.4.7 MBean管理

 6.4.6 虚拟机信息

 6.10 小结

 6.3.2 jstat命令

 &nbsp;

 5.3.13 收集器对系统性能的影响

 6.2.1 任务管理器

 5.3 垃圾收集基础

 5.2.6 堆的比例分配

 6.9.3 堆快照

 6.4.5 类加载情况

 6.9.5 线程视图

 5.5.5 类和对象跟踪

 5.3.2 垃圾回收算法与思想

 5.4.1 将新对象预留在新生代

 5.1.5 方法区

 5.4.2 大对象进入老年代

 5.2.5 设置线程桟

 6.1 Linux命令行工具

 6.5.5 快照

 6.9.4 CPU视图

 6.4.4 线程监控

 5.1.2 Java虚拟机栈

 6.1.5 pidstat工具

 6.6.2 内置heap对象

 5.5.4 取得GC信息

 6.4.8 使用插件

 5.6.2 Web应用程序介绍

 6.1.2 sar命令

 5.4.4 稳定与震荡的堆大小

 5.5.8 Solaris下线程控制

 6.4 JConsole工具

 6.5.9 BTrace介绍

 6.4.3 内存监控

 6.7.6 最大对象报告

 第6章 Java性能调优工具

 6.2.3 Process Explorer

 6.6.4 集合/统计函数

 &nbsp;

 6.5.8 TDA使用

 5.4.6 使用大页案例

 5.4.5 吞吐量优先案例

 6.1.3 vmstat命令

 6.4.1 JConsole连接Java程序

 5.5.1 JIT编译参数

 6.7.10 扩展MAT

 5.3.3 垃圾收集器的类型

 &nbsp;

 6.3 JDK命令行工具

 5.4.7 降低停顿案例

 5.1.3 本地方法栈

 5.2.2 设置最小堆内存

 6.5.3 Thread Dump和分析

 5.1.4 Java堆

 6.9.1 JProfile使用配置

 &nbsp;

 &nbsp;

 &nbsp;

 6.3.5 jhat命令

 &nbsp;

 6.3.4 jmap命令

 6.5.4 性能分析

 6.3.8 hprof工具

 6.7.3 支配树(Dominator Tree)

 5.6.1 Tomcat简介与启动加速

 5.3.4 评价GC策略的指标

 5.5.10 压缩指针

 6.7.5 内存泄露检测

 &nbsp;

 5.6.5 调优过程

 5.2.7 堆分配参数总结

 5.7 总结

 &nbsp;

 6.1.4 iostat命令

 6.1.1 top命令

 &nbsp;

 5.3.11 G1收集器(Garbage First)

 5.5.9 使用大页

 6.2.2 perfmon性能监控工具

 5.4.3 设置对象进入老年代的年龄

 6.9.2 内存视图

 &nbsp;

 &nbsp;

 5.4 常用调优案例和方法

 5.3.10 CMS收集器

 6.8.1 Select子句

 6.7.7 查找支配者

 6.2 Windows工具

 6.8 MAT对OQL的支持

 6.3.3 jinfo命令

 5.3.5 新生代串行收集器

 5.6.4 调优前Web应用运行状况

 5.3.12 Stop the World案例

 5.6 实战JVM调优

 6.5 Visual VM多合一工具

 6.9 JProfile简介

 5.5.7 选择类校验器

 5.1.1 程序计数器

 6.8.4 内置对象与方法

 5.5.2 堆快照(堆Dump)

 5.5 实用JVM参数

 5.5.3 错误处理

 6.3.7 jstatd命令

 6.6.3 对象函数

 6.5.6 内存快照分析

 5.6.3 JMeter介绍与使用

 6.9.6 JVM统计信息

 6.6 Visual VM对OQL的支持V

  