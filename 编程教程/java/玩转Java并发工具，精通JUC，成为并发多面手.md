# 玩转Java并发工具，精通JUC，成为并发多面手

## 联系方式

客服微信号：itziyuan_xiaozhi

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/common/20240614073449/666b82192834a.jpg" width="200" height="200" alt="二维码">

## 课程简介

下载链接：https://it.bcwex.shop/posts?id=5251

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/yun/20241201160625/674c19017824d.jpg" width="500" alt="">

  玩转Java并发工具，精通JUC，成为并发多面手



 

 ├──第10章 控制并发流程【做好线程之间的协调人】

 | ├──10-1 如何控制并发流程？.mp4 36.57M

 | ├──10-2 倒计时门闩，一等多.mp4 61.85M

 | ├──10-3 综合用法：运动员跑步.mp4 78.62M

 | ├──10-4 Semaphore颁发许可证.mp4 46.65M

 | ├──10-5 Semaphore用法和注意点.mp4 49.43M

 | ├──10-6 条件对象的作用和用法演示.mp4 51.90M

 | ├──10-7 用条件对象实现生产者模式.mp4 66.83M

 | ├──10-8 循环栅栏的作用.mp4 48.26M

 | └──10-9 总结控制并发流程的要点.mp4 12.86M

 ├──第11章 AQS【进阶必备，并发灵魂人物】

 | ├──11-1 如何学习AQS？.mp4 44.00M

 | ├──11-10 AQS补充材料（选修）_慕课网.pdf 243.12kb

 | ├──11-2 Semaphore和AQS的关系.mp4 15.41M

 | ├──11-3 比喻：HR和AQS的职责统一.mp4 73.04M

 | ├──11-4 AQS的三要素.mp4 37.35M

 | ├──11-5 AQS源码分析.mp4 69.35M

 | ├──11-6 AQS的许可证颁发.mp4 32.24M

 | ├──11-7 利用AQS实现独占锁.mp4 43.18M

 | ├──11-8 DIY一次性门闩.mp4 61.11M

 | └──11-9 AQS的核心思路.mp4 29.61M

 ├──第12章 获取子线程的执行结果【来而不往非礼也】

 | ├──12-1 Future和Callable的关系.mp4 71.11M

 | ├──12-2 代码演示：submit返回Future对象，快速抽取返回值.mp4 87.73M

 | ├──12-3 批量接收结果.mp4 41.44M

 | ├──12-4 执行时异常和isDone演示.mp4 28.46M

 | ├──12-5 代码演示：默认广告的超时和取消.mp4 79.20M

 | ├──12-6 cancel方法与中断线程.mp4 23.40M

 | ├──12-7 用法二：用FutureTask获取结果.mp4 59.54M

 | └──12-8 总结Future本章.mp4 18.66M

 ├──第13章 从0到1打造高性能缓存【学以致用，直击痛点】

 | ├──13-1 从最简单的缓存出发.mp4 48.02M

 | ├──13-10 用线程池测试缓存性能.mp4 27.59M

 | ├──13-11 用CountDownLatch实现压测.mp4 17.06M

 | ├──13-12 用ThreadLocal确认时间的统一性.mp4 18.02M

 | ├──13-13 打怪升级之路总结.mp4 26.51M

 | ├──13-2 暴露出来的性能和复用性问题.mp4 21.72M

 | ├──13-3 用装饰者模式解耦.mp4 54.34M

 | ├──13-4 用ConcurrentHashMap保证并发安全.mp4 38.99M

 | ├──13-5 用Future解决重复计算问题.mp4 63.23M

 | ├──13-6 原子组合操作填补漏洞.mp4 24.49M

 | ├──13-7 计算错误如何处理？.mp4 41.08M

 | ├──13-8 缓存“污染”问题的解决.mp4 22.33M

 | └──13-9 缓存过期功能和随机性.mp4 44.93M

 ├──第14章 结语【总结全课精华】

 | ├──14-1 全课精华总结 part 1.mp4 56.14M

 | └──14-2 全课精华总结 part 2.mp4 54.68M

 ├──第1章 开宗明义【告诉你：学什么+收获什么】

 | └──1-1 Java并发成神之路——精通JUC并发工具十八般武艺.mp4 18.61M

 ├──第2章 鸟瞰Java并发【上帝视角建立并发知识框架】

 | ├──2-1 并发工具类纵览——建立起Java并发体系的大厦.mp4 31.07M

 | └──2-2 课程各章节思维导图汇总_慕课网.pdf 230.57kb

 ├──第3章 线程池【治理线程的最大法宝】

 | ├──3-1 线程池的自我介绍.mp4 20.48M

 | ├──3-10 线程池状态和使用注意点.mp4 29.33M

 | ├──3-2 增减线程的时机.mp4 21.71M

 | ├──3-3 keepAliveTime和线程工厂.mp4 14.30M

 | ├──3-4 演示内存溢出的情况.mp4 28.88M

 | ├──3-5 线程池用法演示.mp4 37.06M

 | ├──3-6 对比线程池的特点.mp4 12.20M

 | ├──3-7 五虎上将收服线程池.mp4 54.25M

 | ├──3-8 钩子：给线程池加点料.mp4 47.43M

 | └──3-9 Executor家族的辨析.mp4 31.76M

 ├──第4章 ThreadLocal【一次解决老大难问题】

 | ├──4-1 ThreadLocal的两种用法.mp4 6.12M

 | ├──4-10 ThreadLocal的好处.mp4 11.83M

 | ├──4-11 ThreadLocal原理.mp4 11.05M

 | ├──4-12 ThreadLocal的重要方法介绍.mp4 24.10M

 | ├──4-13 重要方法的源码分析.mp4 30.89M

 | ├──4-14 两种场景，殊途同归.mp4 11.46M

 | ├──4-15 收不回来的value.mp4 29.84M

 | ├──4-16 ThreadLocal的空指针异常问题.mp4 27.21M

 | ├──4-17 ThreadLocal在Spring中的应用.mp4 24.38M

 | ├──4-2 进化之路：故事从两个线程说起.mp4 22.00M

 | ├──4-3 进化之路：线程池来帮忙，却好心办坏事.mp4 39.19M

 | ├──4-4 走过的弯路，你的套路.mp4 16.51M

 | ├──4-5 ThreadLocal是救火队长.mp4 23.47M

 | ├──4-6 悔不当初：回顾进化之路.mp4 3.69M

 | ├──4-7 ThreadLocal的第二种用法 part1.mp4 8.35M

 | ├──4-8 ThreadLocal的第二种用法 part2.mp4 34.89M

 | └──4-9 ThreadLocal的两种用法总结.mp4 15.85M

 ├──第5章 不可不说的“锁”事【种类繁多，如何一一突破？】

 | ├──5-1 本章纵览.mp4 6.48M

 | ├──5-10 是否允许一部分人“先富起来”.mp4 17.49M

 | ├──5-11 代码演示：先来后到的特例、优劣、源码分析.mp4 62.70M

 | ├──5-12 共享锁和排它锁的用法.mp4 32.32M

 | ├──5-13 深入理解交互思想.mp4 17.76M

 | ├──5-14 看似读锁按部就班.mp4 30.86M

 | ├──5-15 超越95%面试者的秘籍 part 1.mp4 30.60M

 | ├──5-16 超越95%面试者的秘籍 part 2.mp4 56.86M

 | ├──5-17 读写锁的由奢入俭“易”.mp4 42.93M

 | ├──5-18 循环尝试，不释放CPU.mp4 46.62M

 | ├──5-19 可中断锁.mp4 5.73M

 | ├──5-2 内置锁的能力不足以满足需求.mp4 22.16M

 | ├──5-20 我们如何才能让锁变得更好用？.mp4 9.14M

 | ├──5-21 “锁”事总结.mp4 5.14M

 | ├──5-3 tryLock尝试获取锁.mp4 47.12M

 | ├──5-4 代码演示：获取锁时被中断.mp4 34.31M

 | ├──5-5 锁的可见性保证.mp4 6.93M

 | ├──5-6 互斥同步锁.mp4 13.44M

 | ├──5-7 非互斥同步锁.mp4 22.05M

 | ├──5-8 可重入锁的用法.mp4 29.21M

 | └──5-9 可重入性质和源码解析.mp4 46.55M

 ├──第6章 atomic包【一刻也不能分割】

 | ├──6-1 什么是原子类，有什么作用？.mp4 9.07M

 | ├──6-10 总结原子类.mp4 4.07M

 | ├──6-2 6类原子类纵览.mp4 3.98M

 | ├──6-3 AtomicInteger案例演示.mp4 25.29M

 | ├──6-4 Atomic数组，每个都安全.mp4 38.51M

 | ├──6-5 Atomic引用在自旋锁的应用.mp4 14.58M

 | ├──6-6 把普通变量升级为原子变量.mp4 33.32M

 | ├──6-7 对比新旧工具的运行速度.mp4 39.31M

 | ├──6-8 剖析高速运转的原理.mp4 13.90M

 | └──6-9 功能升级，不限于加操作.mp4 31.66M

 ├──第7章 CAS【不可中断的典范】

 | ├──7-1 什么是CAS.mp4 10.10M

 | ├──7-2 CAS的等价代码、使用案例.mp4 29.31M

 | ├──7-3 CAS的应用场景、源码分析.mp4 23.29M

 | └──7-4 CAS的缺点和总结.mp4 5.72M

 ├──第8章 以不变应万变【最便捷的并发安全之道】

 | ├──8-1 什么是“不变性”？.mp4 41.39M

 | ├──8-2 final变量的赋值时机.mp4 66.73M

 | ├──8-3 final的注意点.mp4 37.96M

 | ├──8-4 栈封闭技术.mp4 69.45M

 | └──8-5 面试题：真假美猴王.mp4 37.47M

 ├──第9章 ConcurrentHashMap等并发集合【面试超高频考点】

 | ├──9-1 并发容器概览.mp4 26.64M

 | ├──9-10 HashMap 1.7和1.8的结构图和特点，红黑树的概念.mp4 19.54M

 | ├──9-11 ConcurrentHashMap 1.7和1.8结构图.mp4 13.81M

 | ├──9-12 ConcurrentHashMap源码分析-.mp4 39.26M

 | ├──9-13 ConcurrentHashMap1.7和1.8的对比，做了哪些升级？.mp4 32.07M

 | ├──9-14 ConcurrentHashMap难道也会发生线程安全问题？：组合操作的玄机.mp4 50.68M

 | ├──9-15 实际生产中并发安全事故的分享、ConcurrentHashMap复习.mp4 33.08M

 | ├──9-16 CopyOnWriteArrayList的适用场景、读写规则.mp4 99.42M

 | ├──9-17 CopyOnWrite设计理念、数据过期问题.mp4 72.11M

 | ├──9-18 CopyOnWrite源码、缺点分析.mp4 29.21M

 | ├──9-19 并发队列简介.mp4 33.43M

 | ├──9-2 集合类的历史，演进过程：Vector和Hashtable.mp4 38.73M

 | ├──9-20 彩蛋：轻松绘制漂亮的UML图.mp4 14.31M

 | ├──9-21 BlockingQueue入门.mp4 22.75M

 | ├──9-22 ArrayBlockingQueue代码演示、源码分析.mp4 50.75M

 | ├──9-23 LinkedBlockingQueue等典型介绍.mp4 39.30M

 | ├──9-24 并发容器总结.mp4 24.05M

 | ├──9-3 前身：同步的HashMap和ArrayList.mp4 24.83M

 | ├──9-4 ConcurrentHashMap概览.mp4 13.23M

 | ├──9-5 Map接口的典型实现类、常用方法演示.mp4 51.46M

 | ├──9-6 彩蛋：调整JDK版本，以便查看对应版本的代码.mp4 42.79M

 | ├──9-7 HashMap的死循环导致CPU100%的问题分析.mp4 23.33M

 | ├──9-8 彩蛋：多线程调试技巧，每个线程独立调试.mp4 38.32M

 | └──9-9 HashMap的死循环分析_慕课网.pdf 221.81kb

 └──concurrency_tools_practice-master.zip 10.65M

  