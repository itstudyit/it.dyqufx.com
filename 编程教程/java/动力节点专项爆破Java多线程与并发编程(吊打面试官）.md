# 动力节点专项爆破Java多线程与并发编程(吊打面试官）

## 联系方式

客服微信号：itziyuan_xiaozhi

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/common/20240614073449/666b82192834a.jpg" width="200" height="200" alt="二维码">

## 课程简介

下载链接：https://it.bcwex.shop/posts?id=99

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/yun/20240515151606/664461368e5ab.jpg" width="500" alt="">

  动力节点专项爆破Java多线程与并发编程(吊打面试官）



 ├──代码

 | └──bjpowernode.com.zip 650.48kb

 ├──讲义

 | └──细说Java多线程与并发编程.pdf 4.71M

 └──视频

 | ├──01

 | | ├──1-1 走进并发编程-计算机的基本组成(1).avi 15.08M

 | | ├──1-1 走进并发编程-计算机的基本组成.avi 18.72M

 | | ├──1-10 Java底层是如何创建一个线程的？.avi 61.11M

 | | ├──1-11 线程有哪些实现方式-内核线程.avi 34.61M

 | | ├──1-12 Linux系统能创建多少个Java线程？.avi 57.96M

 | | ├──1-13 线程有哪些实现方式-用户线程.avi 39.52M

 | | ├──1-14 再认识一下Java中的线程.avi 26.86M

 | | ├──1-15 在Java中创建线程的方式继承Thread.avi 27.33M

 | | ├──1-16 在Java中创建线程的方式实现Runnable.avi 11.68M

 | | ├──1-17 在Java中创建线程的方式实现Callable.avi 30.02M

 | | ├──1-18 在Java中创建线程的方式Executor.avi 15.21M

 | | ├──1-19 在Java中创建线程的方式ThreadPoolTaskExecutor.avi 78.88M

 | | ├──1-2 走进并发编程-认识一下CPU.avi 47.67M

 | | ├──1-20 循序渐进去认识Java线程-一条新的执行路径.avi 42.33M

 | | ├──1-21 循序渐进去认识Java线程-多线程执行创建几个虚拟机栈？.avi 32.04M

 | | ├──1-22 循序渐进去认识Java线程-Java多线程程序如何Debug调试？.avi 19.73M

 | | ├──1-23 循序渐进去认识Java线程-线程start与run方法.avi 38.98M

 | | ├──1-24 循序渐进去认识Java线程-当前线程与休眠.avi 43.91M

 | | ├──1-25 main线程执行结束后，在main线程中创建的子线程是否也自动结束？.avi 42.77M

 | | ├──1-26 守护线程是怎么回事1？.avi 43.99M

 | | ├──1-27 守护线程是怎么回事2？.avi 25.55M

 | | ├──1-28 线程Thread API-join方法1.avi 29.06M

 | | ├──1-29 线程Thread API-join方法2.avi 17.50M

 | | ├──1-3 走进并发编程-摩尔定律.avi 75.27M

 | | ├──1-30 线程Thread API-yield方法.avi 28.01M

 | | ├──1-31 线程Thread API-getContextClassLoader.avi 46.54M

 | | ├──1-32 线程Thread API-interrupt线程中断1.avi 38.10M

 | | ├──1-33 线程Thread API-interrupt线程中断2.avi 16.60M

 | | ├──1-34 线程Thread API-priority线程优先级.avi 15.67M

 | | ├──1-35 Object wait()方法解读.avi 45.66M

 | | ├──1-36 Object wait() notify()方法解读.avi 45.60M

 | | ├──1-37 Object wait() interrupt()方法解读.avi 23.66M

 | | ├──1-38 Object notifyAll()方法解读.avi 21.75M

 | | ├──1-39 Object wait() notify() notifyAll()方法解读.avi 110.91M

 | | ├──1-4 走进并发编程-Amdahl定律.avi 20.23M

 | | ├──1-40 手写实现生产者-消费者模式.avi 18.81M

 | | ├──1-41 手写实现生产者-消费者模式-代码骨架定义.avi 36.91M

 | | ├──1-42 手写实现生产者-消费者模式-生产消费基础代码骨架.avi 16.01M

 | | ├──1-43 手写实现生产者-消费者模式-生产消费代码实现.avi 24.25M

 | | ├──1-44 手写实现生产者-消费者模式-生产消费代码实现.avi 37.56M

 | | ├──1-45 手写实现生产者-消费者模式-生产消费测试.avi 50.57M

 | | ├──1-46 线程阻塞工具类LockSupport.avi 35.61M

 | | ├──1-47 线程阻塞工具类LockSupport-超时阻塞与唤醒.avi 51.34M

 | | ├──1-48 线程阻塞工具类LockSupport-阻塞与唤醒的特点.avi 74.61M

 | | ├──1-49 线程阻塞工具类LockSupport-阻塞与唤醒的特点.avi 14.61M

 | | ├──1-5 什么是并行什么是并发？.avi 30.59M

 | | ├──1-50 线程阻塞工具类LockSupport-阻塞与唤醒的特点.avi 24.03M

 | | ├──1-51 Java线程的6种状态-初始状态NEW.avi 32.06M

 | | ├──1-52 Java线程的6种状态-终止状态TERMINATED.avi 17.77M

 | | ├──1-53 Java线程的6种状态-运行状态RUNNABLE.avi 50.42M

 | | ├──1-54 Java线程的6种状态-等待状态WAITING.avi 26.95M

 | | ├──1-55 Java线程的6种状态-等待状态WAITING转换到运行状态RUNNABLE.avi 49.37M

 | | ├──1-56 Java线程的6种状态-超时等待状态TIMED_WAITING.avi 40.22M

 | | ├──1-57 Java线程的6种状态-阻塞状态BLOCKED.avi 53.42M

 | | ├──1-58 Java线程的6种状态-竞争Lock锁的线程状态.avi 28.94M

 | | ├──1-59 通过jstack查看线程状态.avi 63.04M

 | | ├──1-6 进程与线程.avi 35.73M

 | | ├──1-7 如何查看进程下的线程及CPU占用率-Windows.avi 30.40M

 | | ├──1-8 如何查看进程下的线程及CPU占用率-Linux.avi 20.91M

 | | └──1-9 如何下载JDK源码.avi 20.88M

 | ├──02

 | | ├──2-1 什么是线程池？.avi 17.94M

 | | ├──2-10 线程池内置的四种拒绝策略-丢弃最老和主线程执行策略.avi 52.99M

 | | ├──2-11 线程池自定义拒绝策略.avi 70.55M

 | | ├──2-12 线程池自定义拒绝策略应用场景案例-需求分析.avi 18.28M

 | | ├──2-13 线程池自定义拒绝策略应用场景案例-代码实现.avi 49.25M

 | | ├──2-14 线程池自定义拒绝策略应用场景案例-代码测试.avi 32.79M

 | | ├──2-15 一些开源项目实现的拒绝策略.avi 64.17M

 | | ├──2-16 线程池的核心工作原理.avi 21.02M

 | | ├──2-17 线程池底层源码实现分析-数字的进制.avi 73.55M

 | | ├──2-18 线程池底层源码实现分析-构造方法.avi 38.27M

 | | ├──2-19 线程池底层源码实现分析-控制变量.avi 44.66M

 | | ├──2-2 为什么要有线程池？.avi 17.63M

 | | ├──2-20 线程池底层源码实现分析-线程池状态值.avi 45.70M

 | | ├──2-21 线程池底层源码实现分析-线程池控制变量ctl.avi 22.74M

 | | ├──2-22 线程池底层源码实现分析-解包ctl获取线程池运行状态.avi 73.71M

 | | ├──2-23 线程池底层源码实现分析-解包ctl获取线程池工作线程个数.avi 39.83M

 | | ├──2-24 线程池底层源码实现分析-线程池状态和工作线程数为什么用一个变量而不用两个变量？.avi 35.48M

 | | ├──2-25 线程池底层源码实现分析-线程池状态和工作线程数控制变量？.avi 8.54M

 | | ├──2-26 线程池底层源码实现分析-线程池底层实现核心源码分析1？.avi 48.51M

 | | ├──2-27 线程池底层源码实现分析-线程池底层实现核心源码分析2？.avi 45.66M

 | | ├──2-28 线程池底层源码实现分析-线程池底层实现核心源码分析3？.avi 23.59M

 | | ├──2-29 线程池底层源码实现分析-线程池底层实现核心源码addWorker分析1？.avi 49.98M

 | | ├──2-3 Java线程池之Executor框架.avi 35.00M

 | | ├──2-30 线程池底层源码实现分析-线程池底层实现核心源码addWorker分析2？.avi 53.20M

 | | ├──2-31 线程池底层源码实现分析-线程池底层实现核心源码addWorker分析3？.avi 49.26M

 | | ├──2-32 线程池底层源码实现分析-线程池底层实现核心源码runWorker方法分析.avi 53.18M

 | | ├──2-33 线程池底层源码实现分析-线程池底层实现核心源码getTask方法分析.avi 42.61M

 | | ├──2-34 线程池底层源码实现分析-线程池底层实现核心源码线程复用分析.avi 36.31M

 | | ├──2-35 线程池底层源码实现分析-线程池底层实现核心源码线程个数动态变化分析.avi 76.54M

 | | ├──2-36 线程池底层源码实现分析-线程池底层实现核心源码流程画图总结.avi 66.98M

 | | ├──2-37 工作中线程池的应用1.avi 59.01M

 | | ├──2-38 工作中线程池的应用2.avi 16.72M

 | | ├──2-39 工作中线程池的应用3.avi 40.41M

 | | ├──2-4 Executor框架的接口与类结构.avi 58.65M

 | | ├──2-40 工作中线程池的应用4.avi 61.58M

 | | ├──2-41 如何合理设置线程池大小1？.avi 26.09M

 | | ├──2-42 如何合理设置线程池大小2？.avi 23.73M

 | | ├──2-43 如何合理设置线程池大小3？.avi 36.49M

 | | ├──2-44 如何合理设置线程池大小4？.avi 62.46M

 | | ├──2-45 如何合理设置线程池大小5？.avi 53.91M

 | | ├──2-46 如何设计实现一个动态线程池？.avi 16.93M

 | | ├──2-47 如何设计实现一个动态线程池-环境准备？.avi 47.57M

 | | ├──2-48 如何设计实现一个动态线程池-集成配置中心？.avi 49.41M

 | | ├──2-49 如何设计实现一个动态线程池-代码实现？.avi 82.52M

 | | ├──2-5 线程池的7大参数解读-核心线程数.avi 48.50M

 | | ├──2-50 如何设计实现一个动态线程池-自动刷新1？.avi 13.28M

 | | ├──2-51 如何设计实现一个动态线程池-自动刷新2？.avi 149.74M

 | | ├──2-52 创建线程池的方式及阿里规范.avi 63.94M

 | | ├──2-53 线程池的扩展钩子方法.avi 53.45M

 | | ├──2-54 线程池的监控.avi 62.74M

 | | ├──2-55 线程池的监控-数据定时采集.avi 53.01M

 | | ├──2-56 线程池的监控-数据定时采集代码实现1.avi 90.65M

 | | ├──2-57 线程池的监控-数据定时采集代码实现2.avi 119.29M

 | | ├──2-58 线程池关闭shutdownNow().avi 68.90M

 | | ├──2-59 线程池关闭shutdown().avi 42.93M

 | | ├──2-6 线程池的7大参数解读-任务队列与最大线程数.avi 23.81M

 | | ├──2-60 线程池要不要关闭？.avi 53.71M

 | | ├──2-61 线程池要不要关闭，怎么关闭？.avi 56.44M

 | | ├──2-7 线程池的7大参数解读-空闲线程超时销毁.avi 15.95M

 | | ├──2-8 线程池的7大参数解读-线程工厂.avi 50.22M

 | | └──2-9 线程池内置的四种拒绝策略-异常和丢弃策略.avi 38.79M

 | ├──03

 | | ├──3-1 什么是线程安全？.avi 47.52M

 | | ├──3-10 JOL查看Java对象内存布局.avi 56.96M

 | | ├──3-11 对象头Mark Word中VALUE值解读.avi 49.99M

 | | ├──3-12 偏向锁.avi 51.63M

 | | ├──3-13 偏向锁加锁.avi 32.01M

 | | ├──3-14 偏向锁释放.avi 34.79M

 | | ├──3-15 偏向锁的设计思想.avi 17.82M

 | | ├──3-16 轻量级锁.avi 24.89M

 | | ├──3-17 轻量级锁加锁.avi 67.11M

 | | ├──3-18 轻量级锁释放.avi 80.01M

 | | ├──3-19 轻量级锁的设计思想.avi 15.52M

 | | ├──3-2 线程安全原子性问题.avi 14.08M

 | | ├──3-20 重量级锁.avi 35.94M

 | | ├──3-21 重量级锁底层实现原理.avi 71.42M

 | | ├──3-22 synchronized锁膨胀.avi 78.98M

 | | ├──3-23 重量级锁加锁.avi 55.39M

 | | ├──3-24 重量级锁释放.avi 32.77M

 | | ├──3-25 用户态和内核态.avi 90.63M

 | | ├──3-26 synchronized死锁问题.avi 31.84M

 | | ├──3-27 死锁案例分析.avi 85.49M

 | | ├──3-28 产生死锁的四个必要条件.avi 20.04M

 | | ├──3-29 死锁如何解决1？.avi 51.22M

 | | ├──3-3 线程上下文切换原子性问题.avi 26.70M

 | | ├──3-30 死锁如何解决2？.avi 51.13M

 | | ├──3-31 死锁如何解决3？.avi 18.79M

 | | ├──3-32 synchronized与脏读问题.avi 99.56M

 | | ├──3-33 内存不可见问题.avi 38.61M

 | | ├──3-34 聊聊CPU三级高速缓存.avi 175.06M

 | | ├──3-35 Java内存模型.avi 98.98M

 | | ├──3-36 volatile关键字的应用.avi 30.43M

 | | ├──3-37 volatile可见性与原子性.avi 54.06M

 | | ├──3-38 volatile与有序性.avi 56.08M

 | | ├──3-39 volatile的使用场景.avi 49.65M

 | | ├──3-4 指令原子性问题的分析.avi 30.37M

 | | ├──3-40 多线程单例模式-饿汉式设计.avi 31.60M

 | | ├──3-41 多线程单例模式-懒汉式设计.avi 19.96M

 | | ├──3-42 多线程单例模式-懒汉式安全设计.avi 13.55M

 | | ├──3-43 多线程单例模式-DCL设计.avi 31.30M

 | | ├──3-44 多线程单例模式-DCL重排序设计.avi 10.93M

 | | ├──3-45 多线程单例模式-静态代码块设计.avi 11.35M

 | | ├──3-46 多线程单例模式-静态内部类设计.avi 27.91M

 | | ├──3-47 多线程单例模式-枚举类设计.mp4 80.75M

 | | ├──3-48 饿汉式单例防反射攻击.mp4 84.49M

 | | ├──3-49 饿汉式单例防反序列化攻击.mp4 116.19M

 | | ├──3-5 synchronized解决线程安全.avi 25.68M

 | | ├──3-50 懒汉式单例反射攻击.mp4 101.37M

 | | ├──3-51 懒汉式单例反序列化攻击.mp4 59.55M

 | | ├──3-52 懒汉式单例的攻击问题.mp4 62.40M

 | | ├──3-53 静态代码块反射与序列化攻击.mp4 106.97M

 | | ├──3-54 静态内部类反射与序列化攻击.mp4 79.77M

 | | ├──3-55 枚举类单例反射攻击剖析.mp4 122.24M

 | | ├──3-56 枚举类单例序列化攻击剖析.mp4 78.74M

 | | ├──3-57 单例设计模式性能比较.mp4 98.59M

 | | ├──3-58 开源项目中的单例设计模式.mp4 111.73M

 | | ├──3-6 synchronized对象锁.avi 75.75M

 | | ├──3-7 synchronized类锁.avi 52.99M

 | | ├──3-8 Java对象头Mark Word结构分析.avi 33.55M

 | | └──3-9 Java对象内存布局.avi 27.58M

 | ├──04

 | | ├──4-1 Runnable接口.avi 40.22M

 | | ├──4-2 Callable接口.avi 57.64M

 | | ├──4-3 Future接口.avi 75.33M

 | | ├──4-4 FutureTask类1.avi 45.37M

 | | └──4-5 FutureTask类2.avi 117.75M

 | └──05

 | | ├──5-1 ThreadLocal是什么？.avi 110.38M

 | | ├──5-10 HashMap链表节点过深时为什么选择使用红黑树2？.avi 36.63M

 | | ├──5-11 HashMap链表节点过深时为什么选择使用红黑树3？.avi 44.60M

 | | ├──5-12 什么是hash碰撞，发生hash碰撞怎么办？.avi 51.87M

 | | ├──5-13 ConcurrentHashMap的底层实现原理1？.avi 44.08M

 | | ├──5-14 ConcurrentHashMap的底层实现原理2？.avi 43.00M

 | | ├──5-15 ThreadLocal的实现原理？.avi 82.65M

 | | ├──5-16 ThreadLocal为什么会发生内存泄漏？.avi 51.22M

 | | ├──5-2 ThreadLocal应用.avi 144.78M

 | | ├──5-3 说说你对HashMap的理解和认识？.avi 12.46M

 | | ├──5-4 HashMap有哪些主要特征和注意事项？.avi 35.67M

 | | ├──5-5 说说HashMap的底层数据存储结构？.avi 34.42M

 | | ├──5-6 HashMap多线程条件下死循环是怎么回事？.avi 36.73M

 | | ├──5-7 多线程条件下HashMap数据丢失问题？.avi 26.72M

 | | ├──5-8 多线程条件下HashMap都存在什么问题？.avi 27.29M

 | | └──5-9 HashMap链表节点过深时为什么选择使用红黑树1？.avi 26.09M

  