# C++ 百万并发网络通信引擎架构与实现视频课程

## 联系方式

客服微信号：itziyuan_xiaozhi

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/common/20240614073449/666b82192834a.jpg" width="200" height="200" alt="二维码">

## 课程简介

下载链接：https://it.bcwex.shop/posts?id=3604

<img src="https://ziyuanyun.oss-cn-guangzhou.aliyuncs.com/yun/20240515153432/6644658844c68.jpg" width="500" alt="">

  

 课程目录8 K7 u” j$ c+ j- k/ c9 g3 T0 b

 第1章第1章 搭建多平台下C++开发环境7小时16分钟22节

 1-1课程介绍 32:124 s1 E7 {* l. P” T2 U

 1-218年版_云服务器测试1_Windows_C10K_ 10:54) u% ?4 K2 w0 {

 1-318年版_云测试2_Windows_C100K_十万 13:26

 1-418年版_云服务器测试3_Linux_C10K_1万 19:37

 1-518年版_云服测试4_Linux_C100K_10万 17:04% d! G: d2 v( n; \1 X; E, H

 1-617年版_网络通信引擎_云服务器_演示测试 33:54

 1-7建立 Windows C++开发环境 20:079 N5 E” J/ h5 F0 K

 1-8建立一个易于管理的Windows C++工程 28:56

 1-9VS2015 C++程序常用调试方法39:28

 1-10安装配置SVN代码管理工具116:27

 1-11安装配置SVN代码管理工具220:17

 1-12常用虚拟机软件简介12:528 [7 S- z. u7 w% H/ l f8 _! u8 _

 1-13安装VMware Player 12 并解锁MacOS系统18:205 n6 l6 W$ k” C/ _0 P( [

 1-14在虚拟机中安装MacOS 10.12系统34:29; k+ O, C! {+ J&amp; n) \

 1-15在MacOS 10.12系统中安装Xcode9开发工具13:00

 1-16使用Xcode9.1编写一个MacOS C++程序10:027 z, S# }8 7 `! m

 1-22在vsCode中调试C++项目22:31

 第2章Socket网络通信基础25小时41分钟98节

 2-1Socket 基础Api(TCP篇) 介绍08:07

 2-2Hello Socket22:08

 2-3用Socket API 6步建立TCP服务端45:59

 2-4用Socket API 4步建立客户端26:06! P* C4 h, D; r% z

 2-5建立能持续处理请求的CS网络程序31:46

 2-6用SVN来管理我们的教学项目15:50

 2-7发送结构化的网络消息数据109:31

 2-8发送结构化的网络消息数据207:03. @6 O) F- ]4 U# F

 2-9网络报文的数据格式定义及使用110:33&amp; e6 W&amp; x- ?9 D% @% @9 U

 2-10网络报文的数据格式定义及使用216:11

 2-11网络报文的数据格式定义及使用314:360 l+ T( O0 c# k

 2-12网络报文的数据格式定义及使用408:39‘ h7 f/ K/ K* v$ ~

 2-13将多次收发报文数据升级为一次收发113:59+ F% q1 O# S” M; t+ ~5 h

 2-14将多次收发报文数据升级为一次收发212:02– d2 @0 N&amp; ^’ x/ J, H

 2-15答疑解惑1：网络消息接收长度问题18:39

 2-16服务端升级为select模型处理多客户端105:45” Y; X7 r$ S7 M% M; X; T0 U6 s

 2-17服务端升级为select模型处理多客户端216:17

 2-18服务端升级为select模型处理多客户端321:07

 2-19服务端升级为select模型处理多客户端411:53! q5 }% F/ D9 N- u+ m2 H5 ]

 2-20将服务端select模型设置为非阻塞，处理更多业务08:54* l! C( V% }4 ^! f&amp; Q” P8 m- {‘ `” _

 2-21客户端升级为select网络模型115:28

 2-22客户端升级为select网络模型217:29, t” {/ I* B) y3 ?1 v

 2-23客户端升级为select网络模型316:11

 2-24为客户端添加输入线程(Thread)24:04

 2-25客户端升级1.4跨平台支持Win、Linux、MacOS 110:14&amp; L8 u+ K2 h$ I

 2-26客户端升级1.4跨平台支持Win、Linux、MacOS 212:073 I. q+ m’ p! W* w9 r’ P* w

 2-27客户端升级1.4跨平台支持Win、Linux、MacOS 312:47” d( g$ e0 t- _7 M9 K

 2-28客户端升级1.4跨平台支持Win、Linux、MacOS 408:27

 2-29客户端升级1.4跨平台支持Win、Linux、MacOS 513:20

 2-30服务端升级1.4跨平台支持Win、Linux、MacOS 109:29: B, R# y5 R. C: u- g1 J’ K

 2-31服务端升级1.4跨平台支持Win、Linux、MacOS 208:44‘ e) u1 S W4 }6 ?% ?; n

 2-32服务端升级1.4跨平台支持Win、Linux、MacOS 310:519 O) W; i! o5 t) e/ v

 2-33服务端升级1.4跨平台支持Win、Linux、MacOS 410:21

 2-34服务端升级1.4跨平台支持Win、Linux、MacOS 508:53

 2-35服务端升级1.4跨平台支持Win、Linux、MacOS 608:26

 2-36服务端升级1.4跨平台支持Win、Linux、MacOS 708:52

 2-37服务端升级1.4跨平台支持Win、Linux、MacOS 810:00

 2-38客户端1.5，封装Client类，同时与多个服务端通信112:58

 2-39客户端1.5，封装Client类，同时与多个服务端通信214:33

 2-40客户端1.5，封装Client类，同时与多个服务端通信316:34* c3 e* r3 s$ X( d( Z! [# T2 r

 2-41客户端1.5，封装Client类，同时与多个服务端通信415:55

 2-42验证客户端1.5同时与多个不同平台下的服务端通信112:11

 2-43验证客户端1.5同时与多个不同平台下的服务端通信220:176 E+ N+ z5 \: b3 d6 R

 2-44验证客户端1.5同时与多个不同平台下的服务端通信321:30

 2-45验证客户端1.5同时与多个不同平台下的服务端通信414:55– M$ C% H- |) l9 B’ `: B’ c

 2-46服务端1.5，封装Server类，创建多个Server服务122:16

 2-47服务端1.5，封装Server类，创建多个Server服务216:17! B6 i6 c’ J: [9 b5 l

 2-48服务端1.5，封装Server类，创建多个Server服务314:14* w; W- j6 }1 Q0 K- o+ E

 2-49服务端1.5，封装Server类，创建多个Server服务420:01

 2-50在内外网中验证、测试粘包原因113:22/ t4 P* a+ j7 X2 R; g3 f

 2-51在内外网中验证、测试粘包原因220:44

 2-52在内外网中验证、测试粘包原因320:45# m0 r9 k, {, C

 2-53客户端1.6，解决客户端粘包115:11% t, M8 g! V1 N9 z

 2-54客户端1.6，解决客户端粘包220:150 g2 B) k6 ?&amp; N( n

 2-55客户端1.6，解决客户端粘包316:17# Z! r/ }! s5 U0 r: h) _

 2-56服务端1.6，解决服务端粘包120:42; W) s$ A/ K! k1 t; q3 X, ]* i

 2-57服务端1.6，解决服务端粘包216:47, S4 _9 T W! `0 \( _

 2-58服务端1.6，解决服务端粘包317:30) J! H% U. |/ ~# l$ S+ y2 P

 2-59服务端1.6，解决服务端粘包417:30

 2-60解决粘包测试-Win10专业版-每秒收发1Gb数据06:549 r” |. N# F1 s0 ]

 2-61解决粘包测试-Linux-ubuntu-16.04系统21:50

 2-62解决粘包测试-外网云服务器-远程数据传输14:51: }. f d6 s&amp; d# e8 g6 v+ l; D! \5 G3 R

 2-63突破Windows下select64限制114:08( ^% D1 @* U” _* r9 V3 F7 A* t&amp; d% `8 B

 2-64突破Windows下select64限制213:46

 2-65添加高精度计时器测量处理能力116:26) j j- F! [; g/ g&amp; d. [( J

 2-66添加高精度计时器测量处理能力214:412 c6 Z1 C0 I” g- H) F

 2-67单线程select模型10000连接测试14:25

 2-68多线程与单线程网络程序架构简介18:16; G+ q5 V&amp; G7 ?&amp; X8 z u7 l: r

 2-69多线程-基本概念简介28:03” k3 ?7 \- }0 S* z

 2-70多线程-创建线程，两种启动线程方法的差异19:25

 2-71多线程-传递参数给入口函数，创建线程数组12:49

 2-72多线程-锁与临界区域10:265 G, G0 C8 H# j1 M1 D

 2-73多线程-锁的消耗，通过简单并行计算示例测试17:27

 2-74多线程-自解锁07:31

 2-75多线程-原子操作19:21

 2-76多线程-基本概念总结07:08* m b3 K+ Y7 F&amp; E) Z2 M+ M4 X+ h1 [

 2-77定个小目标，1万连接每秒处理200万个数据包114:399 b5 u2 I1 W0 b( F+ J

 2-78定个小目标，1万连接每秒处理200万个数据包213:14

 2-79客户端1.7_1，多线程分组模拟高频并发数据116:06

 2-80客户端1.7_2，多线程分组模拟高频并发数据215:580 H# O/ u” n2 A

 2-81服务端单线程模式下性能瓶颈测试21:46

 2-82经典设计模式-生产者与消费者模式11:09

 2-83服务端1.7_1，分离新客户端连接与消息处理业务14:40 Z% P$ o/ T+ B8 n

 2-84服务端1.7_2，为消息处理线程添加新客户端缓冲队列14:09

 2-85服务端1.7_3，建立消息处理线程12:308 ?5 f/ g3 A, p, y) p) t3 I’ E

 2-86服务端1.7_4，将新客户端分配给客户数量最少的消息线程10:31( ` p; \0 N1 ]* F, g

 2-87服务端1.7_5，消息处理线程在无客户端时休眠1毫秒13:24

 2-88服务端1.7_6，为消息处理线程添加每秒收包计数17:47

 2-89服务端1.7_7，事件通知，有客户端退出21:11+ F: B) J&amp; c” Q! Q6 _” v! Q+ a&amp; Y( n. R8 v

 2-931.7版，小目标达成，1万连接每秒处理200万包验证测试18:32, f7 Q/ Q: Q; y&amp; w

 2-94小目标达成，注解、补充、代码调整119:575 m5 |# E6 X1 [* f8 ^

 2-95小目标达成，注解、补充、代码调整219:15: H7 t1 P) [4 U4 v

 2-96小目标达成，注解、补充、代码调整324:41

 2-97小目标达成，注解、补充、代码调整424:55% Y5 \1 ]3 ]1 _9 R

 2-98小目标达成，实现自定义Server18:22

 第3章一步一步建立高性能服务器33小时57分钟92节 D, t: J* ^1 `+ @. ~( `

 3-1Server1.7_select模型接收数据性能瓶颈与优化126:45: `3 t; d6 o( R: n” @% O” x

 3-2Server1.7_select模型接收数据性能瓶颈与优化226:11, w- ~, W/ R) `8 j$ T! r8 V&amp; P

 3-3Server1.7_select模型接收数据性能瓶颈与优化323:19

 3-4Server1.7_select模型接收数据性能瓶颈与优化418:425 b1 q. G* V3 _, Q” X( @

 3-5Socket API 极限测试，添加recv和send计数21:530 h4 X. O7 t8 K’ v

 3-6Socket API 极限测试之recv 1 单线程接收测试20:046 N’ C” `7 s% P J/ D

 3-7Socket API 极限测试之recv 2 多线程接收测试23:06” j. A t8 T1 N2 N7 }’ K

 3-8Socket API 极限测试之recv 3 阿里云服务器28:42– B! c; B* i8 R+ r, Q% ^5 x5 W

 3-9Socket API 极限测试之send 119:52; I+ {( i: N6 X. ^/ n( y” }

 3-10Socket API 极限测试之send 219:14

 3-11Socket API 极限测试之send 324:57

 3-12CellServer数据收发的性能瓶颈119:386 v; ]&amp; 7 F, m0 i$ ~# X

 3-28内存池实现217:31% s% \5 j0 Y0 \

 3-29内存池实现319:49

 3-30内存池实现4-初始化内存池22:10

 3-31内存池实现5-实现内存申请14:43( j; @4 Q8 e3 k0 i- g

 3-32内存池实现-6-实现内存释放22:23

 3-33内存池实现-725:59

 3-34内存池实现-821:11

 3-35内存池实现-9-验证调试25:19

 3-36内存池实现-10-验证调试15:34

 3-37内存池实现-1127:26

 3-38内存池实现-1226:496 v+ k; m7 F7 k% 1 X- |/ L* ]$ P2 u5 g( m

 3-49内存管理-智能指针905:39

 3-50内存管理-对象池121:086 ]4 z1 T/ B/ B

 3-51内存管理-对象池219:19

 3-52内存管理-对象池317:54

 3-53内存管理-对象池419:54

 3-54内存管理-对象池525:045 B- f7 w: ’ \- v; U# ?

 3-57内存管理-对象池820:49

 3-58内存管理-总结16:45

 3-59回退到无内存管理07:52&amp; C4 b” ~; v1 e9 @” p4 W

 3-60测试-Linux-ubuntu-16.04系统12:23

 3-61测试-MacOS 10.12系统12:51 {&amp; [. _0 y; k$ w3 b$ u0 i+ r

 3-62优化代码结构138:233 G7 Z7 u; J* _$ {) [

 3-63优化代码结构2-修复发送BUG、减小收发缓冲21:42

 3-64C++11的新特性function与lambda31:27

 3-65使用function与lambda优化TaskServer10:581 _8 H% \’ B- w- o’ R; |4 Y

 3-66心跳检测126:14

 3-67心跳检测227:05, i4 p3 N5 h- }’ s1 O

 3-68心跳检测327:58

 3-69定时发送缓存数据124:36

 3-70定时发送缓存数据224:22+ X2 P” s3 Q7 M( Q3 M

 3-71并发多线程Server安全退出问题分析124:27

 3-72并发多线程Server安全退出问题分析234:06

 3-73实现简单的信号等待机制来控制线程退出23:205 j* r0 d3 A, c) k% k

 3-74封装简单的信号量来控制Sever的关闭35:29, O( T$ h$ x) q0 Y0 Q

 3-75使用condition_variable实现更安全的信号量32:36

 3-76优化线程控制131:00

 3-77优化线程控制2-源码已改为utf8+bom字符编码34:57

 3-78Server2.0_select模型异步发送数据1_utf820:11

 3-79Server2.0_select模型异步发送数据221:02

 3-80Server2.0_select模型异步发送数据320:30&amp; U; q* b2 `4 s4 a0 Y9 i

 3-81Server2.0_select模型异步发送数据528:44

 3-82Server2.0_select模型异步发送数据420:22; c) w, o. J. n/ T

 3-83select模型异步发送6_Linux与MacOS测试26:58– V n5 \&amp; R7 C- |$ a

 3-84Server2.1-分离消息缓冲区125:551 X0 B( r5 ^1 X4 h! C1 k

 3-85Server2.1-分离消息缓冲区224:20

 3-86Server2.1-分离消息缓冲区321:55

 3-87Server2.1-分离消息缓冲区415:05* Z” s0 y. ~/ L2 B9 h

 3-88Server2.1-添加运行日志记录123:032 |* q. c’ l# f

 3-89Server2.1-添加运行日志记录221:57/ t; Y) A’ C) [8 d4 |6 M; E3 @2 w

 3-90Server2.1-添加运行日志记录329:16

 3-91Server2.1-分离网络环境启动与关闭17:44&amp; X; Q” M” q” B6 Z6 R

 3-92Server2.1_Linux与MacOS测试12:45. t$ u2 D7 @/ j7 H m) u, x” V {

 第4章多平台下的客户端网络通信20小时45分钟59节

 4-1为前后端建立通用代码库12:56

 4-2客户端升级为异步收发数据127:03/ K” ?+ o, N, T# X

 4-3客户端升级为异步收发数据225:46

 4-4使用字节流传输数据预览11:13

 4-5字节流1-建立字节流114:54

 4-6字节流2-建立字节流215:10

 4-7字节流3-建立字节流310:48

 4-8字节流4-写入基础类型16:48

 4-9字节流5-写入数组与字符串18:51

 4-10字节流6-读取基础类型17:420 R0 U% ` S; Z6 r1 v! E

 4-11字节流7-读取数组和字符串19:14

 4-12字节流8-读写测试28:40) ?1 w” H* O3 U&amp; v* }# e

 4-13字节流9-分类收发消息流26:27

 4-14字节流10-使用消息流传输数据34:27) T) U4 F9 n! R4 T P

 4-15字节流11-有三段补充14:41! l0 ?2 Y u) e3 r) p8 ?- N# o

 4-16在Unity中使用我们的通信引擎16:24

 4-17Unity_C++插件应用基础114:05

 4-18Unity_C++插件应用基础220:592 m&amp; C+ Q) p% S4 _# }

 4-19Unity_封装插件1_Windows26:31

 4-20Unity_封装插件2_Windows14:12

 4-21Unity_封装插件3_Windows17:32. Z: K1 o6 Y$ e

 4-22Unity_封装插件4_Windows15:19

 4-23Unity_封装插件5_连接服务器12:42) A$ e: l5 d9 `4 r&amp; D- B

 4-24Unity_C#自定义收发字节流数据22:40

 4-25Unity_C#写入流1-基础类型24:39

 4-26Unity_C#写入流2-数组与字符串16:284 z p’ M6 m$ H: D

 4-27Unity_C#写入流3-发送数据-使用测试26:30/ Y- x! I” `/ K’ D

 4-28Unity_C#解析流1-基础类型24:088 q$ j4 o6 {$ u4 L) z+ }

 4-29Unity_C#解析流2-数组与字符串17:10) L- ^7 j3 _8 E1 L

 4-30Unity_C#解析流3-解析数据-收发测试14:42( c) S! {; ~2 c

 4-31Unity_使用C++插件收发字节流数据16:50

 4-32Unity_C++插件导出字节流操作接口31:16

 4-33Unity_C++插件写入流数据32:00( T5 a, }% ~’ b5 _4 H7 {- k

 4-34Unity_C++插件解析流数据29:25! P |2 F- F: t0 e j

 4-35Unity_MacOSX_使用我们的通信引擎18:52

 4-36Unity_IOS_使用我们的通信引擎25:02

 4-37Unity_Android_编译C++动态库120:509 Z: ~5 Q/ _3 g1 Q

 4-38Unity_Android_编译C++动态库219:05

 4-39Unity_Android_编译C++动态库312:557 p) O5 b7 B1 n

 4-40Unity_Android_使用我们的通信引擎120:027 W3 ^( g* c’ k) k* q* p

 4-41Unity_Android_使用我们的通信引擎219:08

 4-42Unity_补充-释放流内存17:46

 4-43在cocos2d-x-cpp中使用我们的通信引擎23:217 V7 J2 I&amp; _5 o$ I: q0 o

 4-44在cocos2d-x-lua中使用我们的通信引擎29:18

 4-45cpp&amp;lua交互1-基础知识31:176 B/ b9 Z’ { B

 4-46cpp&amp;lua交互2-接收和返回字符串11:22

 4-47cpp&amp;lua交互3-注册回调函数20:06

 4-48cpp&amp;lua交互4-tolua14:50

 4-49cpp&amp;lua交互5-NativeClient19:531 S9 S3 q7 ?1 b, |5 w+ ~

 4-50cpp&amp;lua交互6-导出Client接口132:27

 4-51cpp&amp;lua交互7-导出Client接口223:10

 4-52cpp&amp;lua交互8-导出Client接口316:097 l0 J3 E&amp; l$ J0 S! U- s

 4-53cpp&amp;lua交互9-导出Write接口24:581 l( `, ~$ T3 m) b&amp; ]$ L

 4-54cpp&amp;lua交互10-导出Write接口228:07/ N’ i% p) J3 \: u

 4-55cpp&amp;lua交互11-导出Read接口131:05

 4-56cpp&amp;lua交互12-导出Read接口2-收发验证17:30

 4-57cpp&amp;lua交互13-封装Client-lua-class27:04, N7 J( [$ C&amp; U/ y

 4-58cpp&amp;lua交互14-封装写入流-lua-class22:40( {% A3 o$ r7 _1 e” q

 4-59cpp&amp;lua交互15-封装解析流-收发验证30:40

  